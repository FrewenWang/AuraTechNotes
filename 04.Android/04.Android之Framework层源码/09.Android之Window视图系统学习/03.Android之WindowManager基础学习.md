---
title: Android之WindowManager基础学习
date: 2018-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [Android,系统源码,Framework]
type: [Android,系统源码,Framework]
comments: Android之WindowManager基础学习
description: Android之WindowManager基础学习
keywords: Android之WindowManager基础学习
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]

文章参考：https://www.jianshu.com/p/40a9c93b5a8d

文章参考：https://www.cnblogs.com/AronJudge/p/15727806.html

# 概述

WindowManager所提供的功能很简单，常用的只有三个方法，**添加、更新、删除View**，这三个方法定义在ViewManager中，而WindowManager继承了ViewManager。 它操作Window的过程更像是在操作其中的View，拖动Window效果只需要根据手指的位置来设定LayoutParams中的xy的值即可改变Window位置，给View设置onTouchListener，然后在onTouch更新View位置。



# Window作用

通过阅读源码，我们可以看到WindowManager是一个接口。集成自ViewMnager

## ViewManager

```java
package android.view;

/** Interface to let you add and remove child views to an Activity. To get an instance
  * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.
  */
public interface ViewManager {
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}
```



## 添加Window

添加通过WindowManager的addView实现，而manager是一个接口，它的真正实现是WindowManagerImpl类，在Impl类中三大操作实现如下:

```java
public final class WindowManagerImpl implements WindowManager {
    /**
     * WindowManagerGlobal.getInstance()获取单利对象。
     * 这里可以看到所有的WindowManaggerImpl调用的都是同一个对象
     */
    @UnsupportedAppUsage
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerImpl.java
     * @param view
     * @param params
     */
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyTokens(params);
        //  调用mGlobal的addView方法
        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,
                mContext.getUserId());
    }

}
```

交给了WindowManagerGlobal来处理，Global以工厂的形式向外提供自己的实例。

WindowManagerImpl这种模式是典型的桥接模式，把所有操作委托给WindowManagerGlobal来实现，Global的addView方法主要分为以下几步:

### WindowManagerGlobal.addView

1.检查参数是否合法，如果是子View还需要调整一些布局参数

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @param view 所要添加的View
     * @param params View的LayoutParams对象
     * @param display  Display
     * @param parentWindow  当前View的parentWindow
     * @param userId
     */
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow, int userId) {
        // 参数检查：
        // ......

        ViewRootImpl root;
        View panelParentView = null;
        // 进入锁同步模块
        synchronized (mLock) {
            // ......

            // ......

            // If this is a panel window, then find the window it is being
            // attached to for future reference.
            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&
                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                final int count = mViews.size();
                for (int i = 0; i < count; i++) {
                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                        panelParentView = mViews.get(i);
                    }
                }
            }

            IWindowSession windowlessSession = null;
            // If there is a parent set, but we can't find it, it may be coming
            // from a SurfaceControlViewHost hierarchy.
            if (wparams.token != null && panelParentView == null) {
                for (int i = 0; i < mWindowlessRoots.size(); i++) {
                    ViewRootImpl maybeParent = mWindowlessRoots.get(i);
                    if (maybeParent.getWindowToken() == wparams.token) {
                        windowlessSession = maybeParent.getWindowSession();
                        break;
                    }
                }
            }
            // 判断WindowSession是否为null.
            if (windowlessSession == null) {
                root = new ViewRootImpl(view.getContext(), display);
            } else {
                root = new ViewRootImpl(view.getContext(), display,
                        windowlessSession);
            }
            // 给当前View设置setLayoutParams
            view.setLayoutParams(wparams);
            // 比较重要的三个逻辑调用：
            // mViews存储的是所有Window所对应的View
            mViews.add(view);
            // mRoots存储的是所有Window所对应的ViewRootImpl
            mRoots.add(root);
            // mParams存储所有Window所对应的布局参数
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            // ViewRootImpl的setView方法来完成，在setView内部会通过requestLayout来完成异步刷新请求
            try {
                root.setView(view, wparams, panelParentView, userId);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
        }
    }
```

addView的最后通过ViewRootImpl来更新界面并完成Window的添加过程。这个步骤由ViewRootImpl的setView方法来完成，在setView内部会通过requestLayout来完成异步刷新请求

### ViewRootImpl.setView

```java
/**
     * 代码位于：frameworks/base/core/java/android/view/ViewRootImpl.java
     * We have one child
     */
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
            int userId) {
        synchronized (this) {
            if (mView == null) {
                mView = view;

                // ........

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                // 在添加到窗口管理器之前安排第一次布局，以确保我们在从系统接收任何其他事件之前进行布局。
                requestLayout();
                InputChannel inputChannel = null;
                if ((mWindowAttributes.inputFeatures
                        & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                    inputChannel = new InputChannel();
                }
                mForceDecorViewVisibility = (mWindowAttributes.privateFlags
                        & PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;

               // ......
            }
        }
    }
```



在setView内部会通过requestLayout来完成异步刷新请求，关于requestLayout我们这里就不在详细介绍：

具体参见我之前的文章：

下面简单说一下后续的逻辑：





![img](images/03.Android%E4%B9%8BWindowManager%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/webp.webp)





在 WindowManagerService.addWindow 方法中，会创建一个与 Window 对象对应的 WindowState 对象并调用 `WindowState.attach` 方法，然后将该 WindowState 对象添加到 WMS 的 `mWindowMap` Map 中





## 删除View

和添加一样都是先通过WindowManagerImpl后再进一步通过Global来实现

### WindowManagerImpl.removeView

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerImpl.java
     * @param view
     */
    @Override
    public void removeView(View view) {
        mGlobal.removeView(view, false);
    }

    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerImpl.java
     * @param view
     */
    @Override
    public void removeViewImmediate(View view) {
        mGlobal.removeView(view, true);
    }
```

​	通过ViewRootImpl来完成删除操作。在WindowManager中提供了两种删除接口remoteView和remoteViewImmediate，它们分别表示异步删除和同步删除，其中remoteViewImmediate一般不用它来删除Window以免发生以外的错误。在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View没有完成删除操作，最后会将其添加到mDyingViews中，mDyingViews表示待删除的View列表。

### WindowManagerGlobal.removeView

我们来看一下具体的实现：

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @param view 所要删除的View
     * @param immediate  立即同步删除
     */
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    public void removeView(View view, boolean immediate) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }

        synchronized (mLock) {
            int index = findViewLocked(view, true);
            View curView = mRoots.get(index).getView();
            removeViewLocked(index, immediate);
            if (curView == view) {
                return;
            }

            throw new IllegalStateException("Calling with view " + view
                    + " but the ViewAncestor is attached to " + curView);
        }
    }
```



### WindowManagerGlobal.removeViewLocked

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @param view 所要删除的View
     * @param immediate  立即同步删除
     */
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    public void removeView(View view, boolean immediate) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }

        synchronized (mLock) {
            // 查找当前View的索引
            int index = findViewLocked(view, true);
            // 从mRoots里面获取当前View
            View curView = mRoots.get(index).getView();
            // 同步判断是否同步移除当前View  immediate(同步删除)
            removeViewLocked(index, immediate);
            if (curView == view) {
                return;
            }

            throw new IllegalStateException("Calling with view " + view
                    + " but the ViewAncestor is attached to " + curView);
        }
    }
```



### WindowManagerGlobal.removeViewLocked

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @param index 索要删除的View的索引
     * @param immediate  是否同步删除
     */
    private void removeViewLocked(int index, boolean immediate) {
        ViewRootImpl root = mRoots.get(index);
        View view = root.getView();

        if (root != null) {
            root.getImeFocusController().onWindowDismissed();
        }
        // 调用ViewRootImpl的die
        boolean deferred = root.die(immediate);
        if (view != null) {
            view.assignParent(null);
            if (deferred) {
                mDyingViews.add(view);
            }
        }
    }
```

通过ViewRootImpl来完成删除操作。在WindowManager中提供了两种删除接口remoteView和remoteViewImmediate，它们分别表示异步删除和同步删除，其中remoteViewImmediate一般不用它来删除Window以免发生以外的错误。在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View没有完成删除操作，最后会将其添加到mDyingViews中，mDyingViews表示待删除的View列表。



我们来看一下页面的具体实现：

```java
 /**
     * 代码位于：frameworks/base/core/java/android/view/ViewRootImpl.java
     * @param immediate True, do now if not in traversal. False, put on queue and do later.
     * @return True, request has been queued. False, request has been completed.
     */
    boolean die(boolean immediate) {
        // Make sure we do execute immediately if we are in the middle of a traversal or the damage
        // done by dispatchDetachedFromWindow will cause havoc on return.
        // 如果是同步删除，并且不在渲染的递归遍历阶段。则执行doDie
        if (immediate && !mIsInTraversal) {
            doDie();
            return false;
        }

        if (!mIsDrawing) {
            destroyHardwareRenderer();
        } else {
            Log.e(mTag, "Attempting to destroy the window while drawing!\n" +
                    "  window=" + this + ", title=" + mWindowAttributes.getTitle());
        }
        // 如果不是同步删除，或者是同步删除的View正在渲染View递归遍历阶段，则发送Handler步消息删除
        mHandler.sendEmptyMessage(MSG_DIE);
        return true;
    }
```



在die方法中只做了简单的判断，如果是异步删除就发送一个MSG_DIE的消息，ViewRootImpl的Handler会处理此消息并调用doDie方法，如果是同步删除，就直接调用doDie，这就是同步异步删除的区别。真正删除View的逻辑在dispatchDetachedFromWindow方法的内部实现。

### ViewRootImpl.doDie

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/ViewRootImpl.java
     */
    void doDie() {
        checkThread();
        if (LOCAL_LOGV) Log.v(mTag, "DIE in " + this + " of " + mSurface);
        // 进入同步代码块
        synchronized (this) {
            // 如果View已经被移除，则哺育下进行执行
            if (mRemoved) {
                return;
            }
            mRemoved = true;
            mOnBackInvokedDispatcher.detachFromWindow();
            // 如果View已经被添加，则调用dispatchDetachedFromWindow进行移除
            if (mAdded) {
                dispatchDetachedFromWindow();
            }
            // 如果View已经被added进去
            if (mAdded && !mFirst) {
                destroyHardwareRenderer();
                // ......
               
                    destroySurface();
                }
            }

            // If our window is removed, we might not get notified about losing control.
            // Invoking this can release the leashes as soon as possible instead of relying on GC.
            mInsetsController.onControlsChanged(null);

            mAdded = false;
            AnimationHandler.removeRequestor(this);
        }
        WindowManagerGlobal.getInstance().doRemoveView(this);
    }
```

如果View已经被添加，则调用dispatchDetachedFromWindow进行移除,我们看一下这个方法的实现：

### ViewRootImpl.dispatchDetachedFromWindow

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/ViewRootImpl.java
     * 将View从Window中进行移除。
     * 主要工作如下：
     *
     */
    void dispatchDetachedFromWindow() {
        // Make sure we free-up insets resources if view never received onWindowFocusLost()
        // because of a die-signal
        mInsetsController.onWindowFocusLost();
        mFirstInputStage.onDetachedFromWindow();
        if (mView != null && mView.mAttachInfo != null) {
            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);
            // 调用View的dispatchDetachedFromWindow。
            mView.dispatchDetachedFromWindow();
        }

        mAccessibilityInteractionConnectionManager.ensureNoConnection();
        removeSendWindowContentChangedCallback();

        destroyHardwareRenderer();

        setAccessibilityFocus(null, null);

        mInsetsController.cancelExistingAnimations();
        // 清除对应数据
        mView.assignParent(null);
        mView = null;
        mAttachInfo.mRootView = null;
        // 进行Surface的移除
        destroySurface();

        if (mInputQueueCallback != null && mInputQueue != null) {
            mInputQueueCallback.onInputQueueDestroyed(mInputQueue);
            mInputQueue.dispose();
            mInputQueueCallback = null;
            mInputQueue = null;
        }
        try {
            // 调用WindowSession的remove方法进行删除Window
            // mWindowSession.remove(mWindow)，一个IPC过程，最终调用WindowManagerService的removeWindow方法
            mWindowSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        // Dispose receiver would dispose client InputChannel, too. That could send out a socket
        // broken event, so we need to unregister the server InputChannel when removing window to
        // prevent server side receive the event and prompt error.
        if (mInputEventReceiver != null) {
            mInputEventReceiver.dispose();
            mInputEventReceiver = null;
        }

        unregisterListeners();
        unscheduleTraversals();
    }
```

它主要做四件事

1.垃圾回收相关工作：清除数据、移除回调

2.通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，一个IPC过程，最终调用WindowManagerService的removeWindow方法

3.调用View的onDetatchedFromWindow()和onDetatchedFromWindowInternal()，当View从Window中移除时onDetatchedFromWindow()就会被调用，可作资源回收工作

4.调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams、mDyingViews，需要将Window关联的三类对象从列表中移除。





## 更新View

### WindowManagerImpl.updateViewLayout

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerImpl.java
     * @param view
     * @param params
     */
    @Override
    public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyTokens(params);
        mGlobal.updateViewLayout(view, params);
    }

```

### WindowManagerGlobal.updateViewLayout

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @param view
     * @param params
     */
    public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }
        if (!(params instanceof WindowManager.LayoutParams)) {
            throw new IllegalArgumentException("Params must be WindowManager.LayoutParams");
        }
        // 获取当前更新的View的LayoutParams
        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
        // 设置当前View的LayoutParams
        view.setLayoutParams(wparams);
        // 进入同步代码快
        synchronized (mLock) {
            // 根据View获取当前View的index
            int index = findViewLocked(view, true);
            // 获取当前View的管理的root
            ViewRootImpl root = mRoots.get(index);
            // 更新LayoutParams
            mParams.remove(index);
            mParams.add(index, wparams);
            // 设置LayoutParams
            root.setLayoutParams(wparams, false);
        }
    }
```

更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl的LayoutParams。

然后调用ViewRootImpl的setLayoutParams来进行设置lLayoutParam，具体逻辑如下：

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/ViewRootImpl.java
     * @param attrs
     * @param newView
     */
    @VisibleForTesting
    public void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {
        synchronized (this) {
            // ......
            final int changes = mWindowAttributes.copyFrom(attrs);
            if ((changes & WindowManager.LayoutParams.TRANSLUCENT_FLAGS_CHANGED) != 0) {
                // Recompute system ui visibility.
                mAttachInfo.mRecomputeGlobalAttributes = true;
            }
            if ((changes & WindowManager.LayoutParams.LAYOUT_CHANGED) != 0) {
                // Request to update light center.
                mAttachInfo.mNeedsUpdateLightCenter = true;
            }
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }

            // Restore preserved flags.
            // ......

            applyKeepScreenOnFlag(mWindowAttributes);

            if (newView) {
                mSoftInputMode = attrs.softInputMode;
                // 进行调用requestLayout进行更新LayoutParas
                requestLayout();
            }
			// ......

            mWindowAttributesChanged = true;
            // 进行View的调度渲染和遍历
            scheduleTraversals();
        }
    }
```

我们看到更新View的逻辑，进行调用requestLayout进行更新。

同样，在ViewRootImpl中会通过scheduleTraversals方法对View重新布局，包括测量、布局、重绘这三个过程。除了View本身的重绘以外，它还会通过WindowSession来更新Window的视图，这个过程最终由WindowManagerService的relayoutWindow()来具体实现的，它同样是一个IPC过程。

关于requestLayout的具体代码逻辑，我们不在详细介绍，具体看我们之前的文章，文章连接：











