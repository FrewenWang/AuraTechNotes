---
title: Android之WindowManagerService基础学习
date: 2018-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [Android,系统源码,Framework]
type: [Android,系统源码,Framework]
comments: Android之WindowManagerService基础学习
description: Android之WindowManagerService基础学习
keywords: Android之WindowManagerService基础学习
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:

---

[TOC]

文章参考：https://www.jianshu.com/p/9e244d13b866

文章参考：https://www.jianshu.com/p/40776c123adb

文章参考：https://juejin.cn/post/6844903686540541965

# 概述

我们之前学习了WindowManager的基础知识。这篇文章我们分析一下 WindowManagerService（以下简称 WMS）。WMS 错综负责，与 ActivityManagerService、InputManagerService、SurfaceFlinger 关系也很紧密，如果想分析的清楚彻底，恐怕是一两篇文章难以做到的。本篇文章初步分析 WMS 的创建，以及应用进程中的 WindowManager 与 WMS 通信。



# WMS创建

WMS 是在 SystemServer 进程中启动的，SystemServer 进程是 Android 系统启动的时候初始化的。关于SystemServer的基础进程的启动，我们这里不在进行详细的介绍。

参见另外的文章：[SystemServer启动流程分析](../06.Android系统启动之SystemServer进程/01.SystemServer进程的启动流程解析.md)

WMS 错综负责，与 ActivityManagerService、InputManagerService、SurfaceFlinger 关系也很紧密，如果想分析的清楚彻底，恐怕是一两篇文章难以做到的。本篇文章初步分析 WMS 的创建，以及应用进程中的 WindowManager 与 WMS 通信。

下面我们简单说一下WindwowManagerService服务的启动。

### StartWindowManagerService

```java
    /**
     * 代码位于：frameworks/base/services/java/com/android/server/SystemServer.java
     * 启动其他的系统服务
     * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized.
     */
    private void startOtherServices(@NonNull TimingsTraceAndSlog t) {
    		// ......
            // 如下逻辑启动WindowManagerService
            t.traceBegin("StartWindowManagerService");
            // WMS needs sensor service ready
            mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_SENSOR_SERVICE);
            // 调用WindowManmagerService的main函数
            wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,
                    new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);
            // 然后把WindowManmagerService添加到ServiceManager中
            ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false,
                    DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);
            ServiceManager.addService(Context.INPUT_SERVICE, inputManager,
                    /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);
            t.traceEnd();

            t.traceBegin("SetWindowManagerService");
            mActivityManagerService.setWindowManager(wm);
            t.traceEnd();

            t.traceBegin("WindowManagerServiceOnInitReady");
            wm.onInitReady();
            t.traceEnd();
  			// ......
    }
```

如上就是SystemServer中里面启动WindowManagerService的逻辑，注意：这个服务在SystemServer进程启动的。

在上面一段代码中，最重要的莫过于调用 WMS 的 `main()` 方法创建一个 WindowManagerService 对象了，我们来分析下这个方法。

### WindowManagerService.main

```java
    /**
     * 代码位于：frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
     */
    public static WindowManagerService main(final Context context, final InputManagerService im,
            final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy,
            ActivityTaskManagerService atm) {
        // 直接调用Main方法
        return main(context, im, showBootMsgs, onlyCore, policy, atm,
                new DisplayWindowSettingsProvider(), SurfaceControl.Transaction::new, Surface::new,
                SurfaceControl.Builder::new);
    }


    /**
     * 代码位于:frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
     * Creates and returns an instance of the WindowManagerService. This call allows the caller
     * to override factories that can be used to stub native calls during test.
     */
    @VisibleForTesting
    public static WindowManagerService main(final Context context, final InputManagerService im,
            final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy,
            ActivityTaskManagerService atm, DisplayWindowSettingsProvider
            displayWindowSettingsProvider, Supplier<SurfaceControl.Transaction> transactionFactory,
            Supplier<Surface> surfaceFactory,
            Function<SurfaceSession, SurfaceControl.Builder> surfaceControlFactory) {
        // 创建WindowManagerService对象数组
        final WindowManagerService[] wms = new WindowManagerService[1];
        // DisplayThread 线程是一个系统前台线程，用于执行一些延时要非常小的关于显示的操作.
        DisplayThread.getHandler().runWithScissors(() ->
                wms[0] = new WindowManagerService(context, im, showBootMsgs, onlyCore, policy,
                        atm, displayWindowSettingsProvider, transactionFactory, surfaceFactory,
                        surfaceControlFactory), 0);
        return wms[0];
    }
```

如上的代码我们可以看到在DisplayThread的线程创建的WindowManagerService对象。下面我们来看看DisplayThread的线程的实现逻辑。

### DisplayThread

```java
/**
 * 代码位于：frameworks/base/services/core/java/com/android/server/DisplayThread.java
 * Shared singleton foreground thread for the system.  This is a thread for
 * operations that affect what's on the display, which needs to have a minimum
 * of latency.  This thread should pretty much only be used by the WindowManager,
 * DisplayManager, and InputManager to perform quick operations in real time.
 */
public final class DisplayThread extends ServiceThread {
    private static DisplayThread sInstance;
    private static Handler sHandler;

    private DisplayThread() {
        // DisplayThread runs important stuff, but these are not as important as things running in
        // AnimationThread. Thus, set the priority to one lower.
        super("android.display", Process.THREAD_PRIORITY_DISPLAY + 1, false /*allowIo*/);
    }
    /**
     * 其实里面就是封装的HandlerThread
     */
    private static void ensureThreadLocked() {
        if (sInstance == null) {
            sInstance = new DisplayThread();
            sInstance.start();
            sInstance.getLooper().setTraceTag(Trace.TRACE_TAG_SYSTEM_SERVER);
            sHandler = new Handler(sInstance.getLooper());
        }
    }
    public static DisplayThread get() {
        synchronized (DisplayThread.class) {
            ensureThreadLocked();
            return sInstance;
        }
    }
    /**
     * 获取对应HenalerThread的绑定的Handler
     * @return
     */
    public static Handler getHandler() {
        synchronized (DisplayThread.class) {
            ensureThreadLocked();
            return sHandler;
        }
    }
    /**
     * Disposes current display thread if it's initialized. Should only be used in tests to set up a
     * new environment.
     */
    @VisibleForTesting
    public static void dispose() {
        synchronized (DisplayThread.class) {
            if (sInstance == null) {
                return;
            }
            getHandler().runWithScissors(() -> sInstance.quit(), 0 /* timeout */);
            sInstance = null;
        }
    }
}
```



### WindowManagerService构造函数

```java
private WindowManagerService(Context context, InputManagerService inputManager,
            boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy,
            ActivityTaskManagerService atm, DisplayWindowSettingsProvider
            displayWindowSettingsProvider, Supplier<SurfaceControl.Transaction> transactionFactory,
            Supplier<Surface> surfaceFactory,
            Function<SurfaceSession, SurfaceControl.Builder> surfaceControlFactory) {
       // .....

        mLetterboxConfiguration = new LetterboxConfiguration(
                // Using SysUI context to have access to Material colors extracted from Wallpaper.
                ActivityThread.currentActivityThread().getSystemUiContext());
        // 赋值InputManager 必须在createDisplayContentLocked之前
        // 保存 SystemServer 中传入的 InputManagerService 实例对象，输入事件最终要分发给具有焦点的窗口，
        // 而 WMS 是窗口的管理者。mInputManager 用于管理每个窗口的输入事件通道，并向通道上派发事件
        mInputManager = inputManager; // Must be before createDisplayContentLocked.
        mDisplayManagerInternal = LocalServices.getService(DisplayManagerInternal.class);
        mPossibleDisplayInfoMapper = new PossibleDisplayInfoMapper(mDisplayManagerInternal);

        mSurfaceControlFactory = surfaceControlFactory;
        mTransactionFactory = transactionFactory;
        mSurfaceFactory = surfaceFactory;
        mTransaction = mTransactionFactory.get();
        // mPolicy 对象是 WMS 中非常重要的一个对象，是 WindowManagerPolicy 类型的，
        // WindowManagerPolicy（简称 WMP） 是一个接口，具体的实现类是 PhoneWindowManager。
        // mPolicy 对象可以说是 WMS 的首席顾问，WMS 的许多操作都是需要 WMP 规定的，
        // 比如：多个窗口的上下顺序，监听屏幕旋转的状态，预处理一些系统按键事件（例如HOME、BACK键等的默认行为就是在这里实现的）
        mPolicy = policy;
        // 实例化WindowManager 创建一个 WindowAnimator 对象，用于管理所有窗口的动画
        mAnimator = new WindowAnimator(this);
        mRoot = new RootWindowContainer(this);
		// ......
    }
```







# WMS 与 WindowManager 的通信

在上篇文章 初步理解 Window 体系中，我们最后分析到了 ViewRootImpl，ViewRootImpl 是连接 WindowManager 和 WMS 的桥梁，自然他们之间的通信也是通过 ViewRootImpl 完成的。

在 ViewRootImpl 中有两个个非常重要的成员变量：`mWindowSession` 和 `mWindow`，这两个变量都是用于 ViewRootImpl 和 WMS 通信使用的

```java
public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {
    // ......
    final IWindowSession mWindowSession;
    final W mWindow;
    // ......

    public ViewRootImpl(Context context, Display display) {
        mContext = context;
        // 代码 1，通过 WindowManagerGlobal.getWindowSession() 方法得到一个 IWindowSession 对象
        mWindowSession = WindowManagerGlobal.getWindowSession();   
        //......
        // 代码 2，通过 W 构造方法直接创建一个新的 W 对象
        mWindow = new W(this);                                     
        // ......
    }

    // ......
}
```

## IWindowSession

IWindowSession 是一个 AIDL 接口，其服务端进程是 WMS，客户端进程是应用进程，IWindowSession 的创建是在 WindowManagerGlobal 中，如下所示：

```java
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     */
    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    // Emulate the legacy behavior.  The global instance of InputMethodManager
                    // was instantiated here.
                    // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage
                    // getWindowSession()方法中我们可以看出，IWindowSession 对象的创建依赖于 IWindowManager 对象
                    // IWindowManager 也是一个 AIDL 接口，通过 getWindowManagerService() 方法得到其对象，
                    // 在 getWindowManagerService() 方法中，可以看到是典型的 Android 中 Binder
                    // 通信得到服务端在客户端进程中的代理对象的方式，远程端的对象即是 WMS，WMS 实现了 IWindowManager 接口
                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            });
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
```

获取WindowManagerService的AIDL代理类

```
    /**
     * 代码位于：frameworks/base/core/java/android/view/WindowManagerGlobal.java
     * @return
     */
    @UnsupportedAppUsage
    public static IWindowManager getWindowManagerService() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowManagerService == null) {
                // 获取sWindowManagerService代理接口
                sWindowManagerService = IWindowManager.Stub.asInterface(
                        ServiceManager.getService("window"));
                try {
                    if (sWindowManagerService != null) {
                        ValueAnimator.setDurationScale(
                                sWindowManagerService.getCurrentAnimatorScale());
                        sUseBLASTAdapter = sWindowManagerService.useBLAST();
                    }
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowManagerService;
        }
    }
```



回到上面的逻辑，在 `getWindowSession()` 方法中，我们可以看到是调用了 IWindowManager 的 `openSession` 方法，其实际的实现是在 WMS 中，WMS 中的 `openSession` 方法如下所示

## windowManager.openSession



```java
    @Override
    public IWindowSession openSession(IWindowSessionCallback callback) {
        return new Session(this, callback);
    }
```

可以看到，其实 ViewRootImpl 中的 IWindowSession 对象实际对应着 WMS 中的 Session 对象。

## Session对象

```java
class Session extends IWindowSession.Stub implements IBinder.DeathRecipient {
    final WindowManagerService mService;
    final IWindowSessionCallback mCallback;
    final int mUid;
    final int mPid;
    private final String mStringName;
    SurfaceSession mSurfaceSession;
    // mNumWindow 变量记录着此 Session 中共有多少个 Window
    private int mNumWindow = 0;
    
    
    /**
     * 代码位于： frameworks/base/services/core/java/com/android/server/wm/Session.java
     */
    void windowAddedLocked() {
        if (mPackageName == null) {
            final WindowProcessController wpc = mService.mAtmService.mProcessMap.getProcess(mPid);
            if (wpc != null) {
                mPackageName = wpc.mInfo.packageName;
                mRelayoutTag = "relayoutWindow: " + mPackageName;
                mUpdateViewVisibilityTag = "updateVisibility: " + mPackageName;
                mUpdateWindowLayoutTag = "updateLayout: " + mPackageName;
            } else {
                Slog.e(TAG_WM, "Unknown process pid=" + mPid);
            }
        }
        if (mSurfaceSession == null) {
            if (DEBUG) {
                Slog.v(TAG_WM, "First window added to " + this + ", creating SurfaceSession");
            }
            mSurfaceSession = new SurfaceSession();
            ProtoLog.i(WM_SHOW_TRANSACTIONS, "  NEW SURFACE SESSION %s", mSurfaceSession);
            // 将此 Session 对象添加进 WMS 的 mSessions 队列中
            mService.mSessions.add(this);
            if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {
                mService.dispatchNewAnimatorScaleLocked(this);
            }
        }
        // 此Session记录的Windows数量增加
        mNumWindow++;
    }
    

     private void killSessionLocked() {
        if (mNumWindow > 0 || !mClientDead) {
            return;
        }
        // 将此 Session 对象从 WMS 的 mSessions 队列中移除
        mService.mSessions.remove(this);
        if (mSurfaceSession == null) {
            return;
        }

        if (DEBUG) {
            Slog.v(TAG_WM, "Last window removed from " + this
                    + ", destroying " + mSurfaceSession);
        }
        ProtoLog.i(WM_SHOW_TRANSACTIONS, "  KILL SURFACE SESSION %s", mSurfaceSession);
        try {
            mSurfaceSession.kill();
        } catch (Exception e) {
            Slog.w(TAG_WM, "Exception thrown when killing surface session " + mSurfaceSession
                    + " in session " + this + ": " + e.toString());
        }
        mSurfaceSession = null;
        mAlertWindowSurfaces.clear();
        mAppOverlaySurfaces.clear();
        setHasOverlayUi(false);
        cancelAlertWindowNotification();
    }

}
```



WindowManagerGlobal 和 WMS 实现的是单方向的通信，都是通过如下图所示的 Binder 方式进行进程间通信的

![img](images/05.Android%E4%B9%8BWindowManagerService%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/webp.webp)





## W类

W 类是 ViewRootImpl 的一个内部类，实现了 IWindow 接口，IWindow 也是一个 AIDL 接口，可以猜想到，IWindow 接口是供 WMS 使用的，WSM 通过调用 IWindow 一些方法，通过 Binder 通信的方式，最后执行到了 W 中对应的方法中。

```java
public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {


    static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }

        @Override
        public void resized(Rect frame, Rect overscanInsets, Rect contentInsets,
                Rect visibleInsets, Rect stableInsets, Rect outsets, boolean reportDraw,
                MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout,
                boolean alwaysConsumeNavBar, int displayId) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchResized(frame, overscanInsets, contentInsets,
                        visibleInsets, stableInsets, outsets, reportDraw, mergedConfiguration,
                        backDropFrame, forceLayout, alwaysConsumeNavBar, displayId);
            }
        }

        @Override
        public void moved(int newX, int newY) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchMoved(newX, newY);
            }
        }

        @Override
        public void dispatchAppVisibility(boolean visible) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchAppVisibility(visible);
            }
        }

        @Override
        public void dispatchGetNewSurface() {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchGetNewSurface();
            }
        }

        @Override
        public void windowFocusChanged(boolean hasFocus, boolean inTouchMode) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.windowFocusChanged(hasFocus, inTouchMode);
            }
        }

        private static int checkCallingPermission(String permission) {
            try {
                return ActivityManager.getService().checkPermission(
                        permission, Binder.getCallingPid(), Binder.getCallingUid());
            } catch (RemoteException e) {
                return PackageManager.PERMISSION_DENIED;
            }
        }
        
        // ......

    }
}
```





从上面代码可以看到，在 ViewRootImpl 中不仅实现了从 ViewRootImpl 向 WMS 的通信，也实现了从 WMS 向 ViewRootImpl 的通信，如下图所示:

![img](images/05.Android%E4%B9%8BWindowManagerService%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/webp-16693986322942.webp)









