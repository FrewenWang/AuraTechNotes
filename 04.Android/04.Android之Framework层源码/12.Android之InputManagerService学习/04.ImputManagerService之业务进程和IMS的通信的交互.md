---
title: Android之性能监控框架
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [Android,性能优化,性能监控]
type: [Android,性能优化,性能监控]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

文章参考：http://gityuan.com/2016/12/24/input-ui/

# 概述

前面文章都是介绍了两个线程InputReader和InputDispatcher的工作过程。

在InputDispatcher的过程讲到 调用InputChanel通过socket与远程进程通信，本文便展开讲解这个socket是如何建立的。

对于InputReader和InputDispatcher都是运行在system_server进程； 用户点击的界面往往可能是某一个app，而每个app一般地都运行在自己的业务进程，这里就涉及到跨进程通信，app进程是如何与system进程建立通信。

要解答这些问题，从Activity最基本的创建过程开始说起。我们都知道一般地Activity对应一个应用窗口, 每一个窗口对应一个ViewRootImpl。窗口是如何添加到Activity的，从Activity.onCreate()为起点讲解。

众所周知，Activity的生命周期的回调方法都是运行在主线程，也称之为UI线程，所有UI相关的操作都需要运行在该线程。



## Activity.onCreate

```java
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_account_bind);
    ...
}
```

Activity启动是由system进程控制：

1. handleLaunchActivity()：会调用Activity.onCreate(), 该方法内再调用setContentView(),经过AMS与WMS的各种交互,层层调用后,进入step2
2. handleResumeActivity()：会调用Activity.makeVisible(),该方法继续调用便会执行到WindowManagerImpl.addView(), 该方法内部再调用WindowManagerGlobal.addView(),

## ViewRootImpl







# 归纳总结





2. `InputDispatcher`中会先将事件放到`InboundQueue`也就是“iq”队列中，然后寻找具体处理`input`事件的目标应用窗口，并将事件放入对应的目标窗口`OutboundQueue`也就是“oq”队列中等待通过`SocketPair`双工信道发送到应用目标窗口中。
3. 事件发送给具体的应用目标窗口后，会将事件移动到`WaitQueue`也就是“wq”中等待目标应用处理事件完成，并开启倒计时，**如果目标应用窗口在5S内没有处理完成此次触控事件，就会向`system_server`报应用ANR异常事件**。
