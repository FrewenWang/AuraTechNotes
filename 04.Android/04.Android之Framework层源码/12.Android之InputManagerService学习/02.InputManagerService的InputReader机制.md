文章参考：http://gityuan.com/2016/12/11/input-reader/

# 概述



# InputManager::start

```c++
status_t InputManager::start() {
    // 启动InputDispatcher的事件分发
    status_t result = mDispatcher->start();
    if (result) {
        ALOGE("Could not start InputDispatcher thread due to error %d.", result);
        return result;
    }
    // 启动InputReader
    result = mReader->start();
    if (result) {
        ALOGE("Could not start InputReader due to error %d.", result);

        mDispatcher->stop();
        return result;
    }

    return OK;
}
```



# InputDispatcher::start

```c++
status_t InputDispatcher::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputDispatcher线程
    mThread = std::make_unique<InputThread>(
            "InputDispatcher", [this]() { dispatchOnce(); }, [this]() { mLooper->wake(); });
    return OK;
}
```

# InputReader::start

```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
status_t InputReader::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputReader线程
    // 循环调用loopOnce()。整个过程是不断循环的地调用InputReader的loopOnce()方法
    // make_unique的智能指针需要学习
    mThread = std::make_unique<InputThread>(
            "InputReader", [this]() { loopOnce(); }, [this]() { mEventHub->wake(); });
    return OK;
}
```

InputManager的start方法的主要功能是启动两个线程:

- 启动线程“InputReader”
- 启动线程”InputDispatcher“

那么，下面我们看一下InputReader的线程的业务逻辑。InputReader的线程中，回会调用到loopOnce()方法。



## InputReader::loopOnce()



```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
status_t InputReader::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputReader线程
    // 循环调用loopOnce()。整个过程是不断循环的地调用InputReader的loopOnce()方法
    // make_unique的智能指针需要学习
    mThread = std::make_unique<InputThread>(
            "InputReader", [this]() { loopOnce(); }, [this]() { mEventHub->wake(); });
    return OK;
}

status_t InputReader::stop() {
    if (mThread && mThread->isCallingThread()) {
        ALOGE("InputReader cannot be stopped from its own thread!");
        return INVALID_OPERATION;
    }
    mThread.reset();
    return OK;
}
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
void InputReader::loopOnce() {
    int32_t oldGeneration;
    int32_t timeoutMillis;
    bool inputDevicesChanged = false;
    std::vector<InputDeviceInfo> inputDevices;
    { // acquire lock
        AutoMutex _l(mLock);

        oldGeneration = mGeneration;
        timeoutMillis = -1;

        uint32_t changes = mConfigurationChangesToRefresh;
        if (changes) {
            mConfigurationChangesToRefresh = 0;
            timeoutMillis = 0;
            refreshConfigurationLocked(changes);
        } else if (mNextTimeout != LLONG_MAX) {
            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);
        }
    } // release lock
    // 从EventHub读取事件，其中EVENT_BUFFER_SIZE = 256
    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);

    { // acquire lock
        // 获取同步锁
        AutoMutex _l(mLock);
        mReaderIsAliveCondition.broadcast();
        // 处理事件
        if (count) {
            processEventsLocked(mEventBuffer, count);
        }
        if (mNextTimeout != LLONG_MAX) {
            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
            if (now >= mNextTimeout) {
#if DEBUG_RAW_EVENTS
                ALOGD("Timeout expired, latency=%0.3fms", (now - mNextTimeout) * 0.000001f);
#endif
                mNextTimeout = LLONG_MAX;
                timeoutExpiredLocked(now);
            }
        }

        if (oldGeneration != mGeneration) {
            inputDevicesChanged = true;
            getInputDevicesLocked(inputDevices);
        }
    } // release lock

    // Send out a message that the describes the changed input devices.
    // 如果输入设备发生改变。则发送通知告知输入设备发生改变
    if (inputDevicesChanged) {
        mPolicy->notifyInputDevicesChanged(inputDevices);
    }

    // Flush queued events out to the listener.
    // This must happen outside of the lock because the listener could potentially call
    // back into the InputReader's methods, such as getScanCodeState, or become blocked
    // on another thread similarly waiting to acquire the InputReader lock thereby
    // resulting in a deadlock.  This situation is actually quite plausible because the
    // listener is actually the input dispatcher, which calls into the window manager,
    // which occasionally calls into the input reader.
    // 通过监听回调。发送事件到InputDispatcher
    mQueuedListener->flush();
}
```



我们可以看到。InputReader会通过会不断地循环调用loopOnce()。源源不断的从EventHub中获取输入事件。下面，我们就来看一下比较重要的EventHub是怎么获取输入事件的。

## EventHub->getEvents

```c++
/**
 * frameworks/native/services/inputflinger/reader/EventHub.cpp
 **/
size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {
    // 确认缓存数据区空间大于1
    ALOG_ASSERT(bufferSize >= 1);
    // 加锁处理
    AutoMutex _l(mLock);

    struct input_event readBuffer[bufferSize];
    // 定义原始事件
    RawEvent* event = buffer;
    // 传入的缓冲区的大小，一般为256
    size_t capacity = bufferSize;
    bool awoken = false;
    for (;;) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);

        // Reopen input devices if needed.
        if (mNeedToReopenDevices) {
            mNeedToReopenDevices = false;

            ALOGI("Reopening all input devices due to a configuration change.");

            closeAllDevicesLocked();
            mNeedToScanDevices = true;
            break; // return to the caller before we actually rescan
        }

       //......
        // 进行输入事件的设备扫描
        if (mNeedToScanDevices) {
            mNeedToScanDevices = false;
            // TODO 具体扫描设备的逻辑，我们后来再看
            scanDevicesLocked();
            mNeedToSendFinishedDeviceScan = true;
        }
        // 进行设备的添加
        while (mOpeningDevices != nullptr) {
            Device* device = mOpeningDevices;
            ALOGV("Reporting device opened: id=%d, name=%s\n", device->id, device->path.c_str());
            mOpeningDevices = device->next;
            event->when = now;
            event->deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
            event->type = DEVICE_ADDED;
            event += 1;
            mNeedToSendFinishedDeviceScan = true;
            if (--capacity == 0) {
                break;
            }
        }

        if (mNeedToSendFinishedDeviceScan) {
            mNeedToSendFinishedDeviceScan = false;
            event->when = now;
            event->type = FINISHED_DEVICE_SCAN;
            event += 1;
            if (--capacity == 0) {
                break;
            }
        }

        // Grab the next input event.
        bool deviceChanged = false;
        /// 
        while (mPendingEventIndex < mPendingEventCount) {
            /// 从mPendingEventItems读取事件项
            const struct epoll_event& eventItem = mPendingEventItems[mPendingEventIndex++];
            if (eventItem.data.fd == mINotifyFd) {
                if (eventItem.events & EPOLLIN) {
                    mPendingINotify = true;
                } else {
                    ALOGW("Received unexpected epoll event 0x%08x for INotify.", eventItem.events);
                }
                continue;
            }

            if (eventItem.data.fd == mWakeReadPipeFd) {
                if (eventItem.events & EPOLLIN) {
                    ALOGV("awoken after wake()");
                    awoken = true;
                    char buffer[16];
                    ssize_t nRead;
                    do {
                        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
                    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));
                } else {
                    ALOGW("Received unexpected epoll event 0x%08x for wake read pipe.",
                          eventItem.events);
                }
                continue;
            }
            /// 根据eventItem.data.fd。获取设备ID所对应的devices
            Device* device = getDeviceByFdLocked(eventItem.data.fd);
            if (!device) {
                ALOGE("Received unexpected epoll event 0x%08x for unknown fd %d.", eventItem.events,
                      eventItem.data.fd);
                ALOG_ASSERT(!DEBUG);
                continue;
            }
            // ......
            // This must be an input event
            // 
            if (eventItem.events & EPOLLIN) {
                /// 开始从设备中不断的读取事件，放到readerBuffer中。
                int32_t readSize =
                        read(device->fd, readBuffer, sizeof(struct input_event) * capacity);
                if (readSize == 0 || (readSize < 0 && errno == ENODEV)) {
                    // Device was removed before INotify noticed.
                    ALOGW("could not get event, removed? (fd: %d size: %" PRId32
                          " bufferSize: %zu capacity: %zu errno: %d)\n",
                          device->fd, readSize, bufferSize, capacity, errno);
                    deviceChanged = true;
                    // 如果获取不到事件。或者事件为负数。错误码是ENODEV。则设备已经移除
                    // 执行相关的关闭操作
                    closeDeviceLocked(device);
                } else if (readSize < 0) {
                    if (errno != EAGAIN && errno != EINTR) {
                        ALOGW("could not get event (errno=%d)", errno);
                    }
                } else if ((readSize % sizeof(struct input_event)) != 0) {
                    ALOGE("could not get event (wrong size: %d)", readSize);
                } else {
                    int32_t deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;

                    size_t count = size_t(readSize) / sizeof(struct input_event);
                    for (size_t i = 0; i < count; i++) {
                        // 获取readerBuffer数据
                        struct input_event& iev = readBuffer[i];
                        // 
                        event->when = processEventTimestamp(iev);
                        event->deviceId = deviceId;
                        event->type = iev.type;
                        event->code = iev.code;
                        event->value = iev.value;
                        event += 1;
                        capacity -= 1;
                    }
                    if (capacity == 0) {
                        // The result buffer is full.  Reset the pending event index
                        // so we will try to read the device again on the next iteration.
                        mPendingEventIndex -= 1;
                        break;
                    }
                }
            } else if (eventItem.events & EPOLLHUP) {
                ALOGI("Removing device %s due to epoll hang-up event.",
                      device->identifier.name.c_str());
                deviceChanged = true;
                closeDeviceLocked(device);
            } else {
                ALOGW("Received unexpected epoll event 0x%08x for device %s.", eventItem.events,
                      device->identifier.name.c_str());
            }
        }
				// ......
        mPendingEventIndex = 0;
        /// 进行poll之前先释放所
        mLock.unlock(); // release lock before poll
        // 然后等待Input事件的输入
        int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);

        mLock.lock(); // reacquire lock after poll

        if (pollResult == 0) {
            // Timed out.
            mPendingEventCount = 0;
            break;
        }
        // 如果出现的poll事件的错误
        if (pollResult < 0) {
            // An error occurred.
            mPendingEventCount = 0;

            // Sleep after errors to avoid locking up the system.
            // Hopefully the error is transient.
            if (errno != EINTR) {
                ALOGW("poll failed (errno=%d)\n", errno);
                // 系统发生错误，则休眠1秒钟
                usleep(100000);
            }
        } else {
            // Some events occurred.
            mPendingEventCount = size_t(pollResult);
        }
    }

    // All done, return the number of events we read.
    // 当所有的业务处理完毕，则返回所读取到的事件个数
    return event - buffer;
}
```

EventHub采用INotify + epoll机制实现监听目录`/dev/input`下的设备节点，经过EventHub将input_event结构体 + deviceId 转换成RawEvent结构体

```c++
/*
 * A raw event as retrieved from the EventHub.
 * 
 */
struct RawEvent {
    nsecs_t when;           //时间发生的时间点
    int32_t deviceId;       // 产生事件的设备ID
    int32_t type;           // 事件的类型：DEVICE_ADDED(添加)、DEVICE_REMOVED(删除)、
                            // FINISHED_DEVICE_SCAN(扫描完成)、type<FIRST_SYNTHETIC_EVENT(其他事件)
    int32_t code;
    int32_t value;
};

```



## EventHub::scanDevicesLocked

```c++
/**
 * frameworks/native/services/inputflinger/reader/EventHub.cpp
 **/
void EventHub::scanDevicesLocked() {
    // 此处DEVICE_PATH="/dev/input"
    status_t result = scanDirLocked(DEVICE_PATH);
    if (result < 0) {
        ALOGE("scan dir failed for %s", DEVICE_PATH);
    }
    if (isV4lScanningEnabled()) {
        result = scanVideoDirLocked(VIDEO_DEVICE_PATH);
        if (result != OK) {
            ALOGE("scan video dir failed for %s", VIDEO_DEVICE_PATH);
        }
    }
    if (mDevices.indexOfKey(ReservedInputDeviceId::VIRTUAL_KEYBOARD_ID) < 0) {
        createVirtualKeyboardLocked();
    }
}
```





```c++
status_t EventHub::scanDirLocked(const char* dirname) {
    char devname[PATH_MAX];
    char* filename;
    DIR* dir;
    struct dirent* de;
    dir = opendir(dirname);
    if (dir == nullptr) return -1;
    strcpy(devname, dirname);
    filename = devname + strlen(devname);
    *filename++ = '/';
    // 读取/dev/input/目录下所有的设备节点
    while ((de = readdir(dir))) {
        if (de->d_name[0] == '.' &&
            (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0')))
            continue;
        strcpy(filename, de->d_name);
        //打开相应的设备节点
        openDeviceLocked(devname);
    }
    closedir(dir);
    return 0;
}
```





介绍了EventHub从设备节点获取事件的流程，当收到事件后接下里便开始处理事件。







# 归纳总结

`Android` 系统是由事件驱动的，而 `input` 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 `input` 事件驱动，其中的核心就是 `InputReader` 和 `InputDispatcher`。`InputReader` 和 `InputDispatcher` 是跑在 `SystemServer`进程中的两个 `native` 循环线程，负责读取和分发 `Input` 事件。整个处理过程大致流程如下：

InputReader整个过程涉及多次事件封装转换，其主要工作核心是以下三大步骤:

- 首先，system_server进程中的native线程的`InputReader`利用linux的epolle机制监听并且从屏幕驱动读取上报的事件。通过EventHub(监听目录/dev/input)读取事件放入mEventBuffer,而mEventBuffer是一个大小为256的数组, 再将事件input_event转换为RawEvent;
- processEventsLocked: 对事件进行加工, 转换RawEvent -> NotifyKeyArgs(NotifyArgs) 
- QueuedListener->flush：将事件发送到InputDispatcher线程, 转换NotifyKeyArgs -> KeyEntry(EventEntry) 



InputReader线程不断循环地执行InputReader.loopOnce(), 每次处理完生成的是EventEntry(比如KeyEntry, MotionEntry), 接下来的工作就交给InputDispatcher线程。



InputReader线程不断循环地执行InputReader.loopOnce(), 每次处理完生成的是EventEntry(比如KeyEntry, MotionEntry), 接下来的工作就交给InputDispatcher线程。





