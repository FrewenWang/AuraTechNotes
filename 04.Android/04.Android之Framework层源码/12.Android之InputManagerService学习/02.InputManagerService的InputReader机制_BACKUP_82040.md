文章参考：http://gityuan.com/2016/12/11/input-reader/

# 概述



# InputManager::start

```c++
status_t InputManager::start() {
    // 启动InputDispatcher的事件分发
    status_t result = mDispatcher->start();
    if (result) {
        ALOGE("Could not start InputDispatcher thread due to error %d.", result);
        return result;
    }
    // 启动InputReader
    result = mReader->start();
    if (result) {
        ALOGE("Could not start InputReader due to error %d.", result);

        mDispatcher->stop();
        return result;
    }

    return OK;
}
```



# InputDispatcher::start

```c++
status_t InputDispatcher::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputDispatcher线程
    mThread = std::make_unique<InputThread>(
            "InputDispatcher", [this]() { dispatchOnce(); }, [this]() { mLooper->wake(); });
    return OK;
}
```

# InputReader::start

```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
status_t InputReader::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputReader线程
    // 循环调用loopOnce()。整个过程是不断循环的地调用InputReader的loopOnce()方法
    // make_unique的智能指针需要学习
    mThread = std::make_unique<InputThread>(
            "InputReader", [this]() { loopOnce(); }, [this]() { mEventHub->wake(); });
    return OK;
}
```

InputManager的start方法的主要功能是启动两个线程:

- 启动线程“InputReader”
- 启动线程”InputDispatcher“

<<<<<<< HEAD
loopOnce()函数中调用了mReader的loopOnce()函数，这个mReader的类型是InputReader类，它的loopOnce()函数的代码如下：

# InputReader::loopOnce
=======
那么，下面我们看一下InputReader的线程的业务逻辑。InputReader的线程中，回会调用到loopOnce()方法。



## InputReader::loopOnce()


>>>>>>> [ADD] add snpe

```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
<<<<<<< HEAD
=======
status_t InputReader::start() {
    if (mThread) {
        return ALREADY_EXISTS;
    }
    // 启动一个InputReader线程
    // 循环调用loopOnce()。整个过程是不断循环的地调用InputReader的loopOnce()方法
    // make_unique的智能指针需要学习
    mThread = std::make_unique<InputThread>(
            "InputReader", [this]() { loopOnce(); }, [this]() { mEventHub->wake(); });
    return OK;
}

status_t InputReader::stop() {
    if (mThread && mThread->isCallingThread()) {
        ALOGE("InputReader cannot be stopped from its own thread!");
        return INVALID_OPERATION;
    }
    mThread.reset();
    return OK;
}
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
>>>>>>> [ADD] add snpe
void InputReader::loopOnce() {
    int32_t oldGeneration;
    int32_t timeoutMillis;
    bool inputDevicesChanged = false;
    std::vector<InputDeviceInfo> inputDevices;
    { // acquire lock
        AutoMutex _l(mLock);

        oldGeneration = mGeneration;
        timeoutMillis = -1;

        uint32_t changes = mConfigurationChangesToRefresh;
        if (changes) {
            mConfigurationChangesToRefresh = 0;
            timeoutMillis = 0;
            refreshConfigurationLocked(changes);
        } else if (mNextTimeout != LLONG_MAX) {
            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);
        }
    } // release lock
<<<<<<< HEAD
    // 重要：从EventHub读取事件
    // 读取到的事件存储到mEventBuffer中，其中EVENT_BUFFER_SIZE = 256
=======
    // 从EventHub读取事件，其中EVENT_BUFFER_SIZE = 256
>>>>>>> [ADD] add snpe
    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);

    { // acquire lock
        // 获取同步锁
        AutoMutex _l(mLock);
        mReaderIsAliveCondition.broadcast();
<<<<<<< HEAD
        // 处理事件。如果得到的Event的数量大于0，将调用processEventsLocked()函数来处理这些Event。
=======
        // 处理事件
>>>>>>> [ADD] add snpe
        if (count) {
            processEventsLocked(mEventBuffer, count);
        }
        if (mNextTimeout != LLONG_MAX) {
            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
            if (now >= mNextTimeout) {
#if DEBUG_RAW_EVENTS
                ALOGD("Timeout expired, latency=%0.3fms", (now - mNextTimeout) * 0.000001f);
#endif
                mNextTimeout = LLONG_MAX;
                timeoutExpiredLocked(now);
            }
        }

        if (oldGeneration != mGeneration) {
            inputDevicesChanged = true;
            getInputDevicesLocked(inputDevices);
        }
    } // release lock

    // Send out a message that the describes the changed input devices.
    // 如果输入设备发生改变。则发送通知告知输入设备发生改变
    if (inputDevicesChanged) {
        mPolicy->notifyInputDevicesChanged(inputDevices);
    }

    // Flush queued events out to the listener.
    // This must happen outside of the lock because the listener could potentially call
    // back into the InputReader's methods, such as getScanCodeState, or become blocked
    // on another thread similarly waiting to acquire the InputReader lock thereby
    // resulting in a deadlock.  This situation is actually quite plausible because the
    // listener is actually the input dispatcher, which calls into the window manager,
    // which occasionally calls into the input reader.
    // 通过监听回调。发送事件到InputDispatcher
    mQueuedListener->flush();
}
```

<<<<<<< HEAD
processEventsLocked()函数来处理这些Event。Event的类型是RawEvent，定义如下：

```c++
/*
 * A raw event as retrieved from the EventHub.
 * 
 */
struct RawEvent {
    nsecs_t when;           //时间发生的时间点
    int32_t deviceId;       // 产生事件的设备ID
    int32_t type;           // 事件的类型：DEVICE_ADDED(添加)、DEVICE_REMOVED(删除)、
                            // FINISHED_DEVICE_SCAN(扫描完成)、type<FIRST_SYNTHETIC_EVENT(其他事件)
    int32_t code;
    int32_t value;
};
```



我们先来看看getEvents函数的具体实现：

# EventHub::getEvents

```java
=======


我们可以看到。InputReader会通过会不断地循环调用loopOnce()。源源不断的从EventHub中获取输入事件。下面，我们就来看一下比较重要的EventHub是怎么获取输入事件的。

## EventHub->getEvents

```c++
>>>>>>> [ADD] add snpe
/**
 * frameworks/native/services/inputflinger/reader/EventHub.cpp
 **/
size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {
    // 确认缓存数据区空间大于1
    ALOG_ASSERT(bufferSize >= 1);
    // 加锁处理
    AutoMutex _l(mLock);

    struct input_event readBuffer[bufferSize];
    // 定义原始事件
    RawEvent* event = buffer;
    // 传入的缓冲区的大小，一般为256
    size_t capacity = bufferSize;
    bool awoken = false;
    for (;;) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);

        // Reopen input devices if needed.
        if (mNeedToReopenDevices) {
            mNeedToReopenDevices = false;

            ALOGI("Reopening all input devices due to a configuration change.");

            closeAllDevicesLocked();
            mNeedToScanDevices = true;
            break; // return to the caller before we actually rescan
        }

<<<<<<< HEAD
        // Report any devices that had last been added/removed.
        while (mClosingDevices) {
            Device* device = mClosingDevices;
            ALOGV("Reporting device closed: id=%d, name=%s\n", device->id, device->path.c_str());
            mClosingDevices = device->next;
            event->when = now;
            event->deviceId = (device->id == mBuiltInKeyboardId)
                    ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID
                    : device->id;
            event->type = DEVICE_REMOVED;
            event += 1;
            delete device;
            mNeedToSendFinishedDeviceScan = true;
            if (--capacity == 0) {
                break;
            }
        }
=======
       //......
>>>>>>> [ADD] add snpe
        // 进行输入事件的设备扫描
        if (mNeedToScanDevices) {
            mNeedToScanDevices = false;
            // TODO 具体扫描设备的逻辑，我们后来再看
            scanDevicesLocked();
            mNeedToSendFinishedDeviceScan = true;
        }
        // 进行设备的添加
        while (mOpeningDevices != nullptr) {
            Device* device = mOpeningDevices;
            ALOGV("Reporting device opened: id=%d, name=%s\n", device->id, device->path.c_str());
            mOpeningDevices = device->next;
            event->when = now;
            event->deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
            event->type = DEVICE_ADDED;
            event += 1;
            mNeedToSendFinishedDeviceScan = true;
            if (--capacity == 0) {
                break;
            }
        }

        if (mNeedToSendFinishedDeviceScan) {
            mNeedToSendFinishedDeviceScan = false;
            event->when = now;
            event->type = FINISHED_DEVICE_SCAN;
            event += 1;
            if (--capacity == 0) {
                break;
            }
        }

        // Grab the next input event.
        bool deviceChanged = false;
        /// 
        while (mPendingEventIndex < mPendingEventCount) {
            /// 从mPendingEventItems读取事件项
            const struct epoll_event& eventItem = mPendingEventItems[mPendingEventIndex++];
            if (eventItem.data.fd == mINotifyFd) {
                if (eventItem.events & EPOLLIN) {
                    mPendingINotify = true;
                } else {
                    ALOGW("Received unexpected epoll event 0x%08x for INotify.", eventItem.events);
                }
                continue;
            }

            if (eventItem.data.fd == mWakeReadPipeFd) {
                if (eventItem.events & EPOLLIN) {
                    ALOGV("awoken after wake()");
                    awoken = true;
                    char buffer[16];
                    ssize_t nRead;
                    do {
                        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
                    } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));
                } else {
                    ALOGW("Received unexpected epoll event 0x%08x for wake read pipe.",
                          eventItem.events);
                }
                continue;
            }
            /// 根据eventItem.data.fd。获取设备ID所对应的devices
            Device* device = getDeviceByFdLocked(eventItem.data.fd);
            if (!device) {
                ALOGE("Received unexpected epoll event 0x%08x for unknown fd %d.", eventItem.events,
                      eventItem.data.fd);
                ALOG_ASSERT(!DEBUG);
                continue;
            }
<<<<<<< HEAD
            if (device->videoDevice && eventItem.data.fd == device->videoDevice->getFd()) {
                if (eventItem.events & EPOLLIN) {
                    size_t numFrames = device->videoDevice->readAndQueueFrames();
                    if (numFrames == 0) {
                        ALOGE("Received epoll event for video device %s, but could not read frame",
                              device->videoDevice->getName().c_str());
                    }
                } else if (eventItem.events & EPOLLHUP) {
                    // TODO(b/121395353) - consider adding EPOLLRDHUP
                    ALOGI("Removing video device %s due to epoll hang-up event.",
                          device->videoDevice->getName().c_str());
                    unregisterVideoDeviceFromEpollLocked(*device->videoDevice);
                    device->videoDevice = nullptr;
                } else {
                    ALOGW("Received unexpected epoll event 0x%08x for device %s.", eventItem.events,
                          device->videoDevice->getName().c_str());
                    ALOG_ASSERT(!DEBUG);
                }
                continue;
            }
=======
            // ......
>>>>>>> [ADD] add snpe
            // This must be an input event
            // 
            if (eventItem.events & EPOLLIN) {
                /// 开始从设备中不断的读取事件，放到readerBuffer中。
                int32_t readSize =
                        read(device->fd, readBuffer, sizeof(struct input_event) * capacity);
                if (readSize == 0 || (readSize < 0 && errno == ENODEV)) {
                    // Device was removed before INotify noticed.
                    ALOGW("could not get event, removed? (fd: %d size: %" PRId32
                          " bufferSize: %zu capacity: %zu errno: %d)\n",
                          device->fd, readSize, bufferSize, capacity, errno);
                    deviceChanged = true;
                    // 如果获取不到事件。或者事件为负数。错误码是ENODEV。则设备已经移除
                    // 执行相关的关闭操作
                    closeDeviceLocked(device);
                } else if (readSize < 0) {
                    if (errno != EAGAIN && errno != EINTR) {
                        ALOGW("could not get event (errno=%d)", errno);
                    }
                } else if ((readSize % sizeof(struct input_event)) != 0) {
                    ALOGE("could not get event (wrong size: %d)", readSize);
                } else {
                    int32_t deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;

                    size_t count = size_t(readSize) / sizeof(struct input_event);
                    for (size_t i = 0; i < count; i++) {
                        // 获取readerBuffer数据
                        struct input_event& iev = readBuffer[i];
                        // 
                        event->when = processEventTimestamp(iev);
                        event->deviceId = deviceId;
                        event->type = iev.type;
                        event->code = iev.code;
                        event->value = iev.value;
                        event += 1;
                        capacity -= 1;
                    }
                    if (capacity == 0) {
                        // The result buffer is full.  Reset the pending event index
                        // so we will try to read the device again on the next iteration.
                        mPendingEventIndex -= 1;
                        break;
                    }
                }
            } else if (eventItem.events & EPOLLHUP) {
                ALOGI("Removing device %s due to epoll hang-up event.",
                      device->identifier.name.c_str());
                deviceChanged = true;
                closeDeviceLocked(device);
            } else {
                ALOGW("Received unexpected epoll event 0x%08x for device %s.", eventItem.events,
                      device->identifier.name.c_str());
            }
        }
<<<<<<< HEAD
				// 
        if (mPendingINotify && mPendingEventIndex >= mPendingEventCount) {
            mPendingINotify = false;
            readNotifyLocked();
            deviceChanged = true;
        }

        // Report added or removed devices immediately.
        if (deviceChanged) {
            continue;
        }

        // Return now if we have collected any events or if we were explicitly awoken.
        if (event != buffer || awoken) {
            break;
        }

        mPendingEventIndex = 0;
        /// 进行poll之前先释放所
        mLock.unlock(); // release lock before poll
        // 调用epoll_wait来进行等待数据。等待Input事件的输入
=======
				// ......
        mPendingEventIndex = 0;
        /// 进行poll之前先释放所
        mLock.unlock(); // release lock before poll
        // 然后等待Input事件的输入
>>>>>>> [ADD] add snpe
        int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);

        mLock.lock(); // reacquire lock after poll

        if (pollResult == 0) {
            // Timed out.
            mPendingEventCount = 0;
            break;
        }
        // 如果出现的poll事件的错误
        if (pollResult < 0) {
            // An error occurred.
            mPendingEventCount = 0;

            // Sleep after errors to avoid locking up the system.
            // Hopefully the error is transient.
            if (errno != EINTR) {
                ALOGW("poll failed (errno=%d)\n", errno);
                // 系统发生错误，则休眠1秒钟
                usleep(100000);
            }
        } else {
            // Some events occurred.
            mPendingEventCount = size_t(pollResult);
        }
    }

    // All done, return the number of events we read.
    // 当所有的业务处理完毕，则返回所读取到的事件个数
    return event - buffer;
}
```

<<<<<<< HEAD
getEvents的代码也很长，细节就省略了，这里只分析它的主干，getEvents()中会读取每个设备的数据，形成RawEvent结构后放到readBuffer中，如果没有输入事件，将在调用epoll_wait()函数时阻塞等待。

因此，读取event的流程就清楚了，InputReaderThread线程大部分时间都是在epoll_wait()上等待，如果某种设备上有事件到来，将会唤醒线程，从设备中读取数据，读到的数据形成RawEvent结构，存放在mEventBuffer中，然后调用processEventsLocked()函数来处理。

# EventHub::processEventsLocked

```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) {
    for (const RawEvent* rawEvent = rawEvents; count;) {
        int32_t type = rawEvent->type;
        size_t batchSize = 1;
        if (type < EventHubInterface::FIRST_SYNTHETIC_EVENT) {
            int32_t deviceId = rawEvent->deviceId;
            // 根据rawId获取deviceId.然后把属于同一设备的RawEvent一起处理
            while (batchSize < count) {
                if (rawEvent[batchSize].type >= EventHubInterface::FIRST_SYNTHETIC_EVENT ||
                    rawEvent[batchSize].deviceId != deviceId) {
                    break;
                }
                // 设备号相同的话batchSize加一
                batchSize += 1;
            }
#if DEBUG_RAW_EVENTS
            ALOGD("BatchSize: %zu Count: %zu", batchSize, count);
#endif
          	// RawEvent数组中取出连续的同类Event，然后通过processEventsForDeviceLocked()函数一起处理。
            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
        } else {
            // 处理如下设备相关的Event。
            switch (rawEvent->type) {
                // 添加设备和移除设备的Event处理比较简单，只需要增加和删除mDevices列表中Device对象就完成了。
                case EventHubInterface::DEVICE_ADDED:
                    addDeviceLocked(rawEvent->when, rawEvent->deviceId);
                    break;
                case EventHubInterface::DEVICE_REMOVED:
                    removeDeviceLocked(rawEvent->when, rawEvent->deviceId);
                    break;
                    // 设备扫描结束需要调用handleConfigurationChangedLocked()函数来处理设备的配置文件。
                case EventHubInterface::FINISHED_DEVICE_SCAN:
                    handleConfigurationChangedLocked(rawEvent->when);
                    break;
                default:
                    ALOG_ASSERT(false); // can't happen
                    break;
            }
        }
        count -= batchSize;
        rawEvent += batchSize;
=======
EventHub采用INotify + epoll机制实现监听目录`/dev/input`下的设备节点，经过EventHub将input_event结构体 + deviceId 转换成RawEvent结构体

```c++
/*
 * A raw event as retrieved from the EventHub.
 * 
 */
struct RawEvent {
    nsecs_t when;           //时间发生的时间点
    int32_t deviceId;       // 产生事件的设备ID
    int32_t type;           // 事件的类型：DEVICE_ADDED(添加)、DEVICE_REMOVED(删除)、
                            // FINISHED_DEVICE_SCAN(扫描完成)、type<FIRST_SYNTHETIC_EVENT(其他事件)
    int32_t code;
    int32_t value;
};

```



## EventHub::scanDevicesLocked

```c++
/**
 * frameworks/native/services/inputflinger/reader/EventHub.cpp
 **/
void EventHub::scanDevicesLocked() {
    // 此处DEVICE_PATH="/dev/input"
    status_t result = scanDirLocked(DEVICE_PATH);
    if (result < 0) {
        ALOGE("scan dir failed for %s", DEVICE_PATH);
    }
    if (isV4lScanningEnabled()) {
        result = scanVideoDirLocked(VIDEO_DEVICE_PATH);
        if (result != OK) {
            ALOGE("scan video dir failed for %s", VIDEO_DEVICE_PATH);
        }
    }
    if (mDevices.indexOfKey(ReservedInputDeviceId::VIRTUAL_KEYBOARD_ID) < 0) {
        createVirtualKeyboardLocked();
>>>>>>> [ADD] add snpe
    }
}
```

<<<<<<< HEAD
processEventsLocked()处理的RawEvent分成两类，一类是设备发生变化的Event，包括添加设备、移除设备和扫描设备结束3种情况。对于添加设备和移除设备的Event处理比较简单，只需要增加和删除mDevices列表中Device对象就完成了。而对于扫描设备结束的Event，还需要调用handleConfigurationChangedLocked()函数来处理设备的配置文件。

另一类是设备自身产生的Event，例如键盘的按键Event。对于这一类Event，会从RawEvent数组中取出连续的同类Event，然后通过processEventsForDeviceLocked()函数一起处理，函数代码如下：

```c++
/**
 * 代码位于：framework/native/services/inputflinger/reader/InputReader.cpp
 **/
void InputReader::processEventsForDeviceLocked(int32_t eventHubId, const RawEvent* rawEvents,
                                               size_t count) {
    //  根据devicdId得到InputDevice对象                                              
    auto deviceIt = mDevices.find(eventHubId);
    if (deviceIt == mDevices.end()) {
        ALOGW("Discarding event for unknown eventHubId %d.", eventHubId);
        return;
    }

    std::shared_ptr<InputDevice>& device = deviceIt->second;
    if (device->isIgnored()) {
        // ALOGD("Discarding event for ignored deviceId %d.", deviceId);
        return;
    }
    // 调用device的process方法
    device->process(rawEvents, count);
}
```

process()函数处理RawEvent的方式是对每个RawEvent调用它的所有InputMaper对象的process()函数。InputMapper对象其实有多种可能的类型，包括SwitchInputMapper、VibratorInput Mapper、KeyboardInputMapper、CursorInputMapper、TouchInputMapper、SingleTouchInputMapper、MultiTouchInputMapper、JoystickInputMapper。这些类的继承关系如图16.2所示。

![img](https://gitee.com/frewen1225/ImageUploader/raw/master/epub_22690231_160-20211019113712077.jpeg)
=======




```c++
status_t EventHub::scanDirLocked(const char* dirname) {
    char devname[PATH_MAX];
    char* filename;
    DIR* dir;
    struct dirent* de;
    dir = opendir(dirname);
    if (dir == nullptr) return -1;
    strcpy(devname, dirname);
    filename = devname + strlen(devname);
    *filename++ = '/';
    // 读取/dev/input/目录下所有的设备节点
    while ((de = readdir(dir))) {
        if (de->d_name[0] == '.' &&
            (de->d_name[1] == '\0' || (de->d_name[1] == '.' && de->d_name[2] == '\0')))
            continue;
        strcpy(filename, de->d_name);
        //打开相应的设备节点
        openDeviceLocked(devname);
    }
    closedir(dir);
    return 0;
}
```





介绍了EventHub从设备节点获取事件的流程，当收到事件后接下里便开始处理事件。







# 归纳总结

InputReader整个过程涉及多次事件封装转换，其主要工作核心是以下三大步骤:

- getEvents：通过EventHub(监听目录/dev/input)读取事件放入mEventBuffer,而mEventBuffer是一个大小为256的数组, 再将事件input_event转换为RawEvent;
- processEventsLocked: 对事件进行加工, 转换RawEvent -> NotifyKeyArgs(NotifyArgs) 
- QueuedListener->flush：将事件发送到InputDispatcher线程, 转换NotifyKeyArgs -> KeyEntry(EventEntry) 



InputReader线程不断循环地执行InputReader.loopOnce(), 每次处理完生成的是EventEntry(比如KeyEntry, MotionEntry), 接下来的工作就交给InputDispatcher线程。



InputReader线程不断循环地执行InputReader.loopOnce(), 每次处理完生成的是EventEntry(比如KeyEntry, MotionEntry), 接下来的工作就交给InputDispatcher线程。




>>>>>>> [ADD] add snpe

