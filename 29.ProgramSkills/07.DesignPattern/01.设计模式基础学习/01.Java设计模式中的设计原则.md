文章参考：https://www.cnblogs.com/zuoxiaolong/p/pattern26.html


## 概述

我们在学习设计模式的时候，我们都知道有23种设计模式，7种设计原则。那么设计模式和设计原则到底有什么对应关系呢？或者说你清楚的知道一直在用的每种设计模式都遵循哪些设计原则，破坏了哪些设计原则吗？ 下面，我们将会一一来分析一下。


下面，我们依次来回顾一下，这23种设计模式


**设计原则：**  设计模式（总纲）

**创建型：**  单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式

**结构型：**  代理模式、适配器模式、装饰器模式、桥接模式、组合模式   享元模式、外观模式

**行为型：**  观察者模式、模板方法模式、命令模式、状态模式、职责链模式、   解释器模式、中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式

以上便是设计模式的分类，以及每个分类下的设计模式，可以看到其中行为型模式的个数为最多，结构型次之，创建型设计模式最少。

好的，我们再回顾一下设计原则：

- **1、单一职责原则**: 每个类应该有且只有一个职责。(类不应该承担多个职责)
- **2、开闭原则**: 对类的扩展是开放，对修改关闭。(通过继承实现扩展，而非修改类的代码)
- **3、里氏替换原则**: 子类继承父类时，可以实现父类的抽象方法，不要重写父类的方法，子类增加自己特有的方法。
- **4、接口隔离原则**: 接口拆分成更小的和更具体的接口，一个接口只用于一个业务逻辑。(接口避免大而全、做到解耦、高内聚、低耦合)
- **5、迪米特原则**:一个对象应当对其他对象尽可能少的了解 (如果依赖其他对象提供服务，不要直接依赖，而是通过第三者转发)
- **6、合成复用原则**：使用对象组合，而不是继承来达到复用的目的。（少用继承、多用组合, 降低耦合。）
- **7、依赖倒置原则**：程序要依赖于抽象接口，不要依赖于具体实现(简单一句话：面向接口编程)


## 设计模式中的设计原则

我们这篇文章主要是讲解设计模式中的设计原则。所以我们不会去重点讲解每个设计模式的具体细节。所以，笔者将会从以下几个方面去分别介绍每种设计模式。

设计原则：描述每个设计模式都遵循了哪些设计原则，破坏了哪些设计原则。

使用场景：描述这种设计模式的使用场景

相关设计模式：与其它设计模式的关系。

### 创建型设计模式

#### 单例模式

**设计原则**：违背单一职责、开闭原则。

**使用场景**：应用中有对象需要是全局的且唯一 。一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误

**相关设计模式**：

原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。

**归纳总结**：这一条其实很有争议，就是单例类是否是破坏单一职责。只不过从现实来讲，单例类无法扩展必不可免会做到大而全的一个对象，从而破坏单一职责。


#### 简单工厂模式

**设计原则**：遵循单一职责；违背开闭原则。

**使用场景**：对于我们某个产品类我们需要从大量的产品类中去获取，则设计工厂方法通过配置参数来进行实例化生成返回。

**相关设计模式**：

工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象化，在这两者之间做选择，主要看将工厂进一步抽象化是否有必要，通常情况下，如果工厂的作用仅仅是用来制造产品，则没必要使用工厂方法模式。

**归纳总结**：毫无疑问，简单工厂类肯定遵循单一职责，他的职责就是生成对应的产品类。但是麻烦的是，如果我们需要增加一盒产品类的时候，就需要修改原有的工厂方法，违背开闭原则。


#### 建造者模式

**设计原则**：遵循单一职责；违背开闭原则。 

**使用场景**：需要构建一批构建过程相同但表示不同的产品，而构建过程非常复杂

**归纳总结**：建造者类肯定是遵循单一职责的。但是当我们所建造的对象需要新增功能的时候。就需要给建造这类新增建造方法，从而外被开闭原则。


#### 原型模式

**设计原则**：无

**使用场景**：需要在运行时动态的创建指定实例种类的对象，或是需要复用其状态。

**相关设计模式**：无

**归纳总结**：

需要注意创建出来的对象是够可以立即投入使用，容易的错误点：在以为是深度拷贝的情况下，却未实现深度拷贝



### 结构型设计模式


#### 代理模式

**设计原则**：遵循迪米特法则、合成复用原则

**使用场景**：当我们需要修改或者屏蔽某一个或者若干个类的部分功能，复用另一部分功能，可以使用静态代理，若是需要拦截一批类中的

**相关设计模式**：

适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口

**归纳总结**：代理模式侧重点是不让客户端直接访问被代理类。而是通过代理类进行访问。所以这样其实是遵循的迪米特原则（最少知道原则）。而代理类和被代理类之前又是通过组合实现的。所以遵循合成复用原则。


#### 适配器模式

**设计原则**：遵循开闭原则、合成复用原则。

**使用场景**：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法。

**相关设计模式**：

装饰器模式：对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。

**归纳总结**：

适配器模式，我们知道有类适配器、对象适配器。

其中类适配器通过继承被适配的类。从而达到适配原有对象的目的，其实就是利用开闭原则，从而扩展被适配对象，增加适配方法。

对象适配器，则是通过适配器类对象与被适配类对象组合的方法，遵循了合成复用的原则。



#### 装饰器模式

**设计原则**：遵循迪米特法则、单一职责、开闭原则、合成复用原则; 破坏里氏替换原则。

**使用场景**：一个类需要动态的添加功能，且这些功能可以相互叠加，可以通过组合装饰器对象进行扩展。

**相关设计模式**：

​	适配器模式：

**归纳总结**：

装饰器通过继承



#### 装饰器模式

**设计原则**：遵循迪米特法则、单一职责、开闭原则、合成复用原则; 破坏里氏替换原则。

**使用场景**：一个类需要动态的添加功能，且这些功能可以相互叠加，可以通过组合装饰器对象进行扩展。

**相关设计模式**：

​	适配器模式：

**归纳总结**：

装饰器通过继承




#### 策略模式

**设计原则**：遵循迪米特法则、单一职责、开闭原则、合成复用原则; 破坏里氏替换原则。

**使用场景**：一个类需要动态的添加功能，且这些功能可以相互叠加

**相关设计模式**：

**归纳总结**：



### 行为型设计模式

#### 观察者模式

**设计原则**：遵循迪米特法则、开闭原则

**使用场景**：需要将观察者与被观察者进行解耦或者是观察者的种类不确定。

**相关设计模式**：无

**归纳总结**：

观察者模式，只要注册监听被观察者的触发行为事件，对被观察者并不清晰知晓，所以是遵循迪米特法则的。至于开闭原则，



#### 模板方法模式

**设计原则**：遵循里式替换原则。

**使用场景**：一批子类的功能有可提取的公共算法骨架。

**相关设计模式**：无

**归纳总结**：

观察者模式，只要注册监听被观察者的触发行为事件，对被观察者并不清晰知晓，所以是遵循迪米特法则的。至于开闭原则，





#### 策略模式

**设计原则**：遵循单一职责、依赖倒置原则、迪米特法则、开闭原则。

**使用场景**：算法或者策略需要经常替换

**相关设计模式**：无

**归纳总结**：

客户端是否依赖于某一个或若干个具体的策略。