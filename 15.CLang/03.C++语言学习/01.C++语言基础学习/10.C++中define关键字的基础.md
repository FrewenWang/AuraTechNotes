---
title: Android之性能监控框架
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
type: [Android,性能优化,性能监控]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]





文章参考：http://c.biancheng.net/view/187.html

## 概述

C语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。

预编译又叫预处理。预编译不是编译，而是编译前的处理，编译器正式开始编译程序之前，会执行一段预处理程序（又称预处理器）专门对程序执行预处理操作。

C语言程序从编写到运行要经过预处理、编译、汇编和链接这 4 个阶段，但大多数人习惯将前 3 个阶段统称为编译阶段，所以才有了“程序要经过编译和链接后才能运行”的说法。关于各个阶段到底做了哪些工作，C语言程序又是怎样一步步转换为可执行程序的，感兴趣的读者请猛击这里了解详情。



## #define

用 #define 定义标识符的一般形式为：

```
#define  标识符  常量   //注意, 最后没有分号
```

\#define 和 #include 一样，也是以“#”开头的。凡是以“#”开头的均为预处理指令，#define也不例外。

\#define又称宏定义，标识符为所定义的宏名，简称宏。标识符的命名规则与前面讲的变量的命名规则是一样的。#define 的功能是将标识符定义为其后的常量。一经定义，程序中就可以直接用标识符来表示这个常量。是不是与定义变量类似？但是要区分开！变量名表示的是一个变量，但宏名表示的是一个常量。可以给变量赋值，但绝不能给常量赋值。

宏所表示的常量可以是数字、字符、字符串、表达式。其中最常用的是数字。

那么，程序中什么时候会使用宏定义呢？用宏定义有什么好处呢？我们直接写数字不行吗？为什么要用一个标识符表示数字呢？

宏定义最大的好处是“方便程序的修改”。使用宏定义可以用宏代替一个在程序中经常使用的常量。注意，是“经常”使用的。这样，当需要改变这个常量的值时，就不需要对整个程序一个一个进行修改，只需修改宏定义中的常量即可。且当常量比较长时，使用宏就可以用较短的有意义的标识符来代替它，这样编程的时候就会更方便，不容易出错。因此，宏定义的优点就是方便和易于维护。

那么程序在预编译的时候是怎么处理宏定义的呢？或者说是怎么处理预处理指令的呢？

其实预编译所执行的操作就是简单的“文本”替换。对宏定义而言，预编译的时候会将程序中所有出现“标识符”的地方全部用这个“常量”替换，称为“宏替换”或“宏展开”。替换完了之后再进行正式的编译。所以说当单击“编译”的时候实际上是执行了两个操作，即先预编译，然后才正式编译。#include<stdio.h>也是这样的，即在预处理的时候先单纯地用头文件stdio.h中所有的“文本”内容替换程序中#include<stdio.h>这一行，然后再进行正式编译。

需要注意的是，预处理指令不是语句，所以后面不能加分号。这是很多新手经常犯的错误。#include 后面也没有加分号。

宏定义 #define 一般都写在函数外面，与 #include 写在一起。当然，写在函数里面也没有语法错误，但通常不那么写。#define 的作用域为自 #define 那一行起到源程序结束。

## \#undef

如果要终止其作用域可以使用 #undef 命令，格式为：

```cmake
#undef  标识符
```

那么这个宏的作用范围到此就结束了。#undef 用得不多，但大家要了解。

## 	#ifndef

它是if not define 的简写，是宏定义的一种，实际上确切的说，这应该是预处理功能三种（宏定义、文件包含、条件编译）中的一种----条件编译。

**在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。**

**但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。**

**使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。**

```c
#ifndef x                 //先测试x是否被宏定义过
#define x
   程序段1blabla~    //如果x没有被宏定义过，定义x，并编译程序段 1
#endif   
　　程序段2blabla~　　 //如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1
```



## #ifdef

与ifndef类似，ifdef顾名思义，就是if define，看例子

```
#ifdef  x
    程序1blabla~
#endif
```

翻译：如果宏定义了x，则执行程序1.

　　此外，还有其他形式，还是看例子好些：

```
#ifndef  x
#define x
    程序段 1
#else
    程序段 2
#endif
```





## 宏参数字符串化

C/C++ 的宏中:

1.# 的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。也就是说：

```cmake
#define __TO_STRING_IMPL(x) #x 
```

中的#X， 则宏变量X所引用的是宏参数中的X，因为，#X会直接对参数X进行字符串化，因此该参数输出的是字符串“X”。

```
　　使用： __TO_STRING_IMPL（15）， 输出：“15”
```

为了能够进一步增加宏的参数输入，因此需要在外部再包括一个宏转化，这样就可以把"转化宏"中的具体参数传入到参数化宏中，这样就可以变为相应“具体参数”的字符串。

如下图所示：

```c++
#define __TO_STRING(x) __TO_STRING_IMPL(x)
```

2.##连接符号由两个井号组成，其功能是在带参数的宏定义中将两个子串联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。

作用：只是用所引用的宏变量替换后，将两个字符串串接起来，形成新的字符串。

如下：

```
#define A(x) T_##x
使用：A（1），则输出：T_1
```

3.#@, 表示将参数作为字符形式替换

如下：

```
#define B(x) #@x
使用： B（1），输出：’1‘
```



## 面试题-typedef和define有什么区别

（1）用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。

（2）执行时间不同：typedef是编译过程的一部分，有类型检查的功能。define是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

（3）作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是正确的。

（4）对指针的操作不同：typedef和define定义的指针时有很大的区别。

注意：typedef定义是语句，因为句尾要加上分号。而define不是语句，千万不能在句尾加分号。
