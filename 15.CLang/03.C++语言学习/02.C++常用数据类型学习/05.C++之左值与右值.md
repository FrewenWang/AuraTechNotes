文章参考：https://zhuanlan.zhihu.com/p/138210501

## 概述

**左值(lvalue, left value)**，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。

**右值(rvalue, right value)**，右边的值，是指表达式结束后就不再存在的临时对象。

区分左值和右值是很重要的，这是使用C++11 move语义的基础。c++11标准基本上是通过举例来说明一个表达式是否是一个lvalue还是rvalue的。

```c++
lvalue = rvalue;
```

对于以上的语句，lvalue是我们要赋值的对象。它是一个变量，存在于内存中，它的值可以被改变，**可以被取地址**。任何可以通过它的名字，指针或者引用来接触的变量都是lvalue，例如定义的某个变量和函数的参数， 对一个表达式取地址。

rvalue则是一个临时变量，不存在于内存中，存在于CPU的寄存器或者指令的立即数中(immediate number)，因此我们不能改变它的值，**不能取地址**。它们通常是一个直接的数值，运算符返回的数值，或是函数的返回值，或者通过隐式类型转换得到的对象，大部分字面值(e.g., 10 and 5.3)也是rvalues。

```c++
int a;  
a = 2;  //a是左值，2是右值
a = 3;  //左值可以被更改，编译通过
2 = 3;  //右值不能被更改，错误

int b = 3;  
int* pb = &b;  //pb是左值，&b是右值，因为它是由取址运算符返回的值
&b = 0;  //错误，右值不能被更改

// lvalues:
int i = 42;
i = 43; // ok, i is an lvalue 
int* p = &i; // ok, i is an lvalue 
int& foo();
foo() = 42; // ok, foo() is an lvalue
int* p1 = &foo(); // ok, foo() is an lvalue
// rvalues: 
int foobar(); 
int j = 0;
j = foobar(); // ok, foobar() is an rvalue
int k = j + 2; // ok, j+2 is an rvalue
int* p2 = &foobar(); // error, cannot take the address of an rvalue 
j = 42; // ok, 42 is an rvalue
```

那么，函数是不是就只可以作为右值呢？其实不是。考虑一个我们司空见惯的例子：

```c++
vector<int> vec = {1,2,3,4,5};
vec[1] = 99; // overloaded operator[]
```

我们看到，其实`operator[]`是一个函数，其返回值依然可以作为左值。

而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。

**纯右值(prvalue, pure rvalue)**，纯粹的右值，没有标识符、不可以取地址的表达式， 要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。

**将亡值(xvalue, expiring value)**，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。

xvalue可能稍有些难以理解，我们来看这样的代码：

```c++
std::vector<int> foo() {
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;
}

std::vector<int> v = foo();
```

