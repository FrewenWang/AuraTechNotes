---
title: Android之性能监控框架
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
type: [Android,性能优化,性能监控]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]



## 概述

​		C++中除了指定变量名称来存取数据之外，在计算机的运行中也有针对内存地址存取的工具，即指针（Pointer）。指针本身是一种变量类型，存储的内容就是内存的地址。大家可以想象把身份证号码当成变量的地址，有了身份证号码，自然就可以知道该位人士的个人资料（变量内容）了。通过指针变量，程序就可以直接存取该指针变量所指向的地址内容。



在C++中，定义变量之后，系统就会开始为此变量分配内存空间，以供程序使用。当需要使用某个数据时，存取那一个地址的内存空间即可。如果我们要更清楚地了解变量所在内存的地址，可以通过&（取址运算符）来得到变量所在的地址，语法格式如下：

```
    &变量名称；
```



```c++
    01  #include <iostream>
    02  #include <cstdlib>
    03
    04  using namespace std;
    05
    06  int main()
    07  {
    08       int num1 = 10;
    09      char ch1[2] = "A"; //声明变量num1、ch1
    10
    11      cout<<"变量名称 变量值 内存地址"<<endl;
    12       cout<< "----------------------------"<<endl;
    13       cout<<"num1 "<<"\t "<<num1<<'\t'<<&num1<<endl;
    14       cout<<"ch1  "<<"\t "<<ch1<<'\t'<<&ch1<<endl;
    15      //使用&运算符打印变量num1、ch1的数值与地址
    16
    17       system("pause");
    18       return 0;
    19  }
```





## 指针变量的声明

​		所谓指针变量，就是一种用来存储内存地址的变量，当指针变量指向目标地址后，可以通过程序来移动指针（包括将指针变量值进行数值运算），取得该地址所代表的内存区块的数据值。

​		由于指针也是一种变量，命名规则与一般变量相同，因此当程序声明一个指针时，内存分配的情况与一般的变量声明相同。声明指针时，首先必须定义指针的数据类型，并在数据类型后加上“*”符号，再赋予指针名称，即可声明一个指针变量。特别补充一点，一旦确定指针所指向的数据类型，就不能再更改了。另外，指针变量也不能指向不同数据类型的指针变量。

​		指针变量声明方式如下：

	数据类型＊ 指针名称； // 第一种声明方式
	
	// 也可以如下方式声明：
	数据类型 ＊指针名称； // 第二种声明方式，＊字号位置不同
	
	// 例如：
	int＊ piVal;
​		以上声明的意义为一个指向int的指针类型变量，其名称为piVal。通常好的指针命名习惯会在变量名称前加上小写p。若是整数类型的指针，则可在变量名称前加上“pi”两个小写字母，“i”代表整数类型（int）。在此要再提醒大家一下，良好的命名规则对于程序日后的判读与维护会有莫大帮助。

​		由于指针属于系统底层的存取功能，因此通过指针可以存取内存中所指向的内存区内容。假如赋予指针错误的地址，而该地址又刚好是系统数据存储的内存区，此时若覆盖（override）该内存区的内容，很可能会造成系统不稳定或者宕机的情况。另外，如果声明指针时未指定初值，就经常会让指针指向未知的内存地址。

​		因此，在编写程序时，指针变量务必确实指向合法地址，才不会造成非预期的运行结果。所谓合法地址，通常是指系统分配给程序的地址，如程序已声明或定义的变量（或数组），然后将指针变量指向该变量的地址，也就是为指针设置初值。声明方式如下：

```
    数据类型 ＊指针变量；
    指针变量=&变量名称；// 变量名称已定义或声明
    或
    数据类型 ＊指针变量=&变量名称；
```

​		或者也可以在指针变量声明时先设置初值为0（或是NULL），声明方式如下：

```
    数据类型 ＊指针变量=0;
    (或 数据类型 ＊指针变量=NULL; )
    数据类型 ＊指针变量=&变量名称；
```

​		第一种方式：

```
    int Value=10;
    int＊ piVal=&Value;
```

​	



```
    01  #include <iostream>
    02  #include <cstdlib>
    03
    04  using namespace std;
    05
    06  int main()
    07  {
    08      int iVal=10;         // 整数变量
    09      double dVal=123.45;   //双精度实数变量
    10
    11      int＊ piVal=NULL; // 声明为空指针
    12      piVal= &iVal;   //整数类型的指针变量，指向iVal变量的地址
    13
    14      double＊ pdVal=&dVal;    //实数类型的指针变量，指向dVal变量的地址
    15
    16      cout<<"piVal变量地址为"<<piVal<<endl;
    17      cout<<"piVal变量所指向地址的数据内容为"<<＊piVal<<endl;
    18
    19     ＊piVal=20; // 重新设置piVal指针变量的数据内容为20
    20      cout<<"piVal指针变量重新设置后，iVal的数据内容同步更改为"<<iVal<<endl;
    21      cout<<"整数iVal所占用的内存空间为："<<sizeof(iVal)<<"位"<<endl;
    22      cout<<"整数指针变量piVal所占用的内存空间为："<<sizeof(piVal)<<"位"<<endl<<endl;
    23
    24      cout<<"pdVal变量地址为"<<pdVal<<endl;
    25      cout<<"pdVal变量所指向地址的数据内容为"<<＊pdVal<<endl;
    26
    27      ＊pdVal=67.1234; //重新设置pdVal指针变量的数据内容为67.1234
    28      cout<<"pdVal指针变量重新设置后，dVal的数据内容同步更改为"<<dVal<<endl;
    29      cout<<"双精度实数dVal所占用的内存空间为："<<sizeof(dVal)<<"位"<<endl;
    30      cout<<"双精度实数指针变量pdVal所占用的内存空间为："<<sizeof(pdVal)<<endl;
    31
    32       system("pause");
    33       return 0;
    34  }
```



### 指针与数组

在C++中，我们知道当声明数组时会由系统分配一段连续的内存空间。事实上，“数组名”就是指向数组中第一个元素的内存地址，也可以代表该数组在内存中的起始地址。“下标值”其实就是其他元素相对于第一个元素的内存地址的“偏移量”（offset）。



因此，对于已定义好的数组，也可以直接使用数组名来进行指针加法运算，也就是数组名可以直接当成一种指针常数来用，并能使用指针的各种运算。例如，只要在数组名上加1，表示移动一个数组元素内存的偏移量。或者通过取址运算符“&”取得该数组元素的地址，并以指针方式直接存取数组内的元素值。两种语法如下：

```
    数组名[下标值]= ＊数组名(+下标值)
    或
    数组名[下标值]= ＊(&数组名[下标值])
```



数组可以直接当成指针常数来用，而数组名地址则是数组第一个元素的地址。不过由于数组的地址是只读的，因此不能改变其值，这点是和指针变量最大的不同。例如：

```
                  int  arr[2][3], value=100;
                  int  ＊ptr=&value;
                  arr=ptr;  //此行不合法，因为arr是只读的，不能重新设置其值
```



下面，我们看一个例子：

```
    01  #include <iostream>
    02  #include <cstdlib>
    03
    04  using namespace std;
    05
    06  int main()
    07  {
    08      int arr[] = { 10, 20, 30, 40, 50}; //声明数组arr及其元素
    09       int i;
    10
    11       for ( i = 0; i < 5; i++ )
    12           cout<<"arr["<<i<<"] = "<<arr[i]<<"  ＊(arr+"<< i<<")="<<＊(arr+i)<<"
    ＊(&arr["<<i<<"])="<<＊(&arr[i])<<endl;
    13      //打印数组与指针常数的替代运算
    14       system("pause");
    15       return 0;
    16  }
```





## 动态分配功能

动态分配内存（Dynamic Allocation）是指当程序在运行时才提出分配内存的要求，主要目的是让内存运用更有弹性。从程序本身的角度来看，动态分配机制可以使数据声明的操作在程序运行时再做决定。

对于编写程序而言，通常声明变量都采用“静态分配”（Static Allocation）的方式，也就是所有变量声明必须在编译阶段完成，这也往往会造成某些不便之处。例如，许多程序员往往会苦恼该如何事先声明适当的数组大小，如果事先声明的长度过大，内存使用的效率就不高，声明得过小，则容易面临存储空间不足的问题。



### 动态分配与静态分配

这时如果通过动态分配方式，程序中不确定的使用空间（如数组长度）即可在程序运行时再按照用户的设置与需求适当分配所需要的内存空间。特别是内存容量不充足时，如果程序运行都以静态声明方式分配内存，很容易造成程序无法运行的窘境。虽然动态分配内存的方式比一般静态分配更具有弹性，不过还是有一些意想不到的缺点，例如动态分配内存后必须在程序结束前完成释放内存的操作。



如果程序运行期间分配的内存未释放，就会造成内存空间的浪费，形成所谓的内存泄漏（memory leak），这种情况对于需要一次使用海量内存的程序而言将有可能无法运行或导致系统运行越来越缓慢等情况发生。静态及动态分配内存两种方式的比较如表6-1所示。



![](https://gitee.com/frewen1225/ImageUploader/raw/master/img/20210215155719.png)





### 动态分配变量

在C++中，可以分别使用new与delete运算符在程序运行期间动态分配与释放内存空间。其中，new运算符会根据所要求的内存大小在内存中分配足够的空间，并返回所分配内存的指针值，也就是内存地址。

由于使用new运算符所分配的内存空间在程序运行期间将会一直占据内存，因此当不再使用时必须使用delete运算符来释放内存空间。

接着就来介绍C++动态分配变量的方式，也就是在运行时按照数据类型来动态分配一个内存空间，并将分配的内存空间地址返回并赋值给指针变量。这个数据类型除了C++的基本数据类型外，也可以包括结构（structure）等自定义数据类型，声明格式如下：

```
    数据类型 ＊指针变量=new数据类型(初值);
```

​		声明完毕时，new运算符会向系统申请分配内存，如果分配成功就返回该内存的地址，如分配失败就返回NULL值。使用new运算符动态分配内存时，可同时设置其初值。若不设置初值，可将小括号省略，如下所示：

```
    int ＊p_I=new int(77);   // 动态分配int数据类型，且＊p_I=77
    float ＊p_F=new float;  // 动态分配float数据类型，且未设置初值
```

​		另外，因为使用new运算符分配的内存空间将会保留到程序运行结束时才归还给系统，所以当分配的内存不再使用时就要用delete运算符来释放该内存空间，否则分配的内存过多时将会影响到程序可用的内存空间，从而降低程序运行的效率。释放内存空间的语句如下：

```
    delete指针名称；
```

​		使用delete运算符释放内存时，该指针变量所指的内存地址必须是原来new运算符所分配的地址，否则将会造成无法预期的运行结果，如下所示：

```
    delete指针名称；
```

​		使用delete运算符释放内存时，该指针变量所指的内存地址必须是原来new运算符所分配的地址，否则将会造成无法预期的运行结果，如下所示：

```
    int ＊ptr=new int;  // 分配内存，并赋值给＊ptr指针变量
    ptr++;     // 指针变量所指向的地址递增1，即往后位移4byte(int类型)
    delete ptr;
```



​	下面，我们看一个例子：

```
    01  #include <iostream>
    02  #include <cstdlib>
    03
    04  using namespace std;
    05
    06  int main()
    07  {
    08        int ＊ptr_1=new int;    // 定义 ＊ptr_1 指针，并由new分配内存
    09        int ＊ptr_2=new int;    // 定义 ＊ptr_2 指针，并由new分配内存
    10
    11        cout << "输入被加数：";
    12        cin >> ＊ptr_1;                        // ＊ptr_1 存储被加数
    13        cout << "输入加数  :";
    14        cin >> ＊ptr_2;                       // ＊ptr_2 存储加数
    15
    16         cout << ＊ptr_1 << " + " << ＊ptr_2 << " = ";
    17        cout << ＊ptr_1+＊ptr_2;             // 计算总和
    18
    19        cout << endl;                     // 换行
    20
    21        delete ptr_1;              // 释放分配给ptr_1 的内存空间
    22        delete ptr_2;          // 释放分配给ptr_2 的内存空间
    23
    24         system("pause");
    25         return 0;
    26  }
```

​		







1. 面试题-简述指针常量与常量指针区别

指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

举例如下：

```c++
int main(){
       int ival =55;
       int jval =38;

       //pa为指向常量的指针,不能通过pa改变其指向的ival的值；但pa可以指向其他变量.[常量指针==指针指向的值为常量]

       const int *pa= &ival;

       //*pa =88;           //报错：l-valuespecifies const object

       pa =&jval;

       cout <<*pa << endl;  //正确. 38

       //pb为常量，指向变量的指针,pb不能修改,但可以修改pb指向的值。[指针常量==指针本身是个常量]

       int* const pb= &ival;

       //     pb = &jval;

       //     cout << *pb << endl;  //l-value specifies const object

       *pb = 2012;

       cout <<*pb << "\t" << ival << endl; //2012 2012

       //pc针对上述两种修改都不可以。

       const int*const pc = &ival;

       cout <<*pc << endl;      //2012

       return 0;

}
```





