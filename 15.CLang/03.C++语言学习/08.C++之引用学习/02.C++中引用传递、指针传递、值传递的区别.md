---
title: C++中引用传递、指针传递、值传递的区别
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [C++,引用,指针]
type: [C++,引用,指针]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]

# 概述

文章参考：https://blog.csdn.net/loongkingwhat/article/details/82469423

# 值传递

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

但是需要记住：值传递存在拷贝过程



# 指针传递

指针参数传递本质上就是值传递，只不过它传递的是一个地址值。形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

指针传递过程中，被调用函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间存放主调函数传递进来的实参的值。从而形成了实参的一个副本（替身）。值传递的特点是：被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值（形参指针变了。实参指针不会变）

# 引用传递

形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。



# 代码解析

```c++
#include<iostream>
using namespace std;
//值传递
 void change1(int n){
    cout<<"值传递--函数操作地址"<<&n<<endl;         //显示的是拷贝的地址而不是源地址 
    n++;
}

//引用传递
void change2(int & n){
    cout<<"引用传递--函数操作地址"<<&n<<endl; 
    n++;
}
 //指针传递
void change3(int *n){
     cout<<"指针传递--函数操作地址 "<<n<<endl; 
    *n=*n+1;
 } 
int     main(){
    int n=10;
    cout<<"实参的地址"<<&n<<endl;
    change1(n);
    cout<<"after change1() n="<<n<<endl;
    change2(n);
    cout<<"after change2() n="<<n<<endl;
    change3(&n);
    cout<<"after change3() n="<<n<<endl;
    return true;
}
```



# 原理解析

## 原理解析

**指针**从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变;

**引用**是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

**相同点：**

都是地址的概念：指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

**不同点：**

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有 的， 前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

●引用不能为空，必须在定义的时候同时进行初始化。指针可以为空，任何时候初始化都可；

●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

## **编译角度解析：**

程序在编译的时候分别将指针和引用添加到符号表中，符号表中记录的变量名和变量对应的地址。指针变量在符号表上对应的地址值为指针变量的地址值。而引用在符号表中对应的地址值是引用对象的地址值（与实参名字不同，地址相同）符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以修改）而引用对象则不能修改。













