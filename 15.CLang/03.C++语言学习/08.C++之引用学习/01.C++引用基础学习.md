---
title: ++引用基础学习
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [Android,性能优化,性能监控]
type: [Android,性能优化,性能监控]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]



## 概述

引用(Reference)是C++语言相对于C语言的又一个扩充，是C++常用的一个重要内容之一。类似于指针，只是在声明的时候用"&"取代了"*"。正确、灵活地使用引用，可以使程序简洁、高效。我在工作中发现，许多人使用它仅仅 是想当然，在某些微妙的场合，很容易出错，究其原由，大多因为没有搞清本源。故在本篇中我将对引用进行详细讨论，希望对大家更好地理解和使用引用起到抛砖 引玉的作用。

引用

 引用是别名，在声明时必须初始化，在实际代码中主要用作函数的形参

（1）&在此不是求地址运算，而是起标识作用。
		（2）类型标识符是指目标变量的类型。
		（3）声明引用时，必须同时对其进行初始化。
		（4）引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
ra=1; 等价于 a=1;

（5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
		（6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。





## 引用的使用

引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。

```c++
//此处函数的形参p1, p2都是引用
void swap(int &p1, int &p2) 
{ int p; p=p1; p1=p2; p2=p; }
```

为在程序中调用该函数，则相应的主调函数的调用点处，直接以变量作为实参进行调用即可，而不需要实参变量有任何的特殊要求。如：对应上面定义的swap函数，相应的主调函数可写为：

```
main( )
{
　int a,b;
　cin>>a>>b; //输入a,b两变量的值
　swap(a,b); //直接以变量a和b作为实参调用swap函数
　cout<<a<< ' ' <<b; //输出结果
}
```

上述程序运行时，如果输入数据10 20并回车后，则输出结果为20 10。

（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。

（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的 形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

## 常引用

常引用声明方式：const类型标识符&引用名=目标变量名；

用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。

```c++
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
```

　这不光是让代码更健壮，也有些其它方面的需要。

假设有如下函数声明：

```c++
string foo( );
void bar(string & s);
// 那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
```

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。

引用型参数应该在能被定义为const的情况下，尽量定义为const。







