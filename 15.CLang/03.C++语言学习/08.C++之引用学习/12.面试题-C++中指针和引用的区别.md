---
title: 面试题-C++中指针和引用的区别
date: 2022-01-05 00:00:00
updated: 2022-01-05 00:00:00
tags: [C++,引用]
type: [C++,引用]
comments: 性能优化框架介绍
description: 页面描述
keywords: 关键字
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

[TOC]

文章参考：https://developer.aliyun.com/article/709155#slide-2

# 概述

指针和引用主要有以下区别：

# 指针

本质上指针是一个变量，只不过这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。所在他在逻辑上和真实的变量是独立。它可以被改变，包括其所指向的地址的改变，或者是其指向地址的所存放的数据的改变。

# 引用

引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。他在逻辑上不是独立的，它就是代表变量本身，所在他的存在具有依附性。这个也很好理解，它只是给一个变量起了一个别名，但是首先得有一个变量才能起别名啊！所以引用一开始就必须被初始化。而且其引用的对象在整个生命周期不能被改变（自始至终只能依附于一个变量）



# 指针和引用的使用

在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：

- **指针传递**:指针传递参数本质上是 **值传递**的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在**栈**中开辟了内存空间以存放由主调函数放进来的 实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
- **引用传递**:引用传递过程中， 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间 接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

引用传递和指针传递是 不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针 传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的 指针，或者指针引用。



# 指针和引用的区别

（1）引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。 引用未初始化，编译器会报错![referencesmust be initialized]

（2）引用初始化以后不能被改变，指针可以改变所指的对象。

（3）不存在指向空值的引用，但是存在指向空值的指针。

注意：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能会引发错误。所以使用时一定要小心谨慎。

## 相同点：

都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

## 不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●**引用没有\**const\**，指针有\**const\**，\**const\**的指针不可变**；

**●引用不能为空，指针可以为空**；

●“***\*sizeof\** 引用**”得到的是所指向的变量(对象)的大小，而“***\*sizeof\** 指针**”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）